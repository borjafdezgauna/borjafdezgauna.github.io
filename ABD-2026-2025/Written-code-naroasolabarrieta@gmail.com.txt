ColumnDefinition.cs (38) : if (value == null)
ColumnDefinition.cs (41) : return value.Replace(DelimiterEncoded, Delimiter);
Database.cs (108) : Table table = TableByName(tableName);
Database.cs (109) : if (table == null)
Database.cs (110) : {
Database.cs (111) : LastErrorMessage = Constants.TableDoesNotExistError;
Database.cs (114) : if (columnCondition != null &&
Database.cs (115) : table.ColumnIndexByName(columnCondition.ColumnName) == -1)
Database.cs (116) : {
Database.cs (117) : LastErrorMessage = Constants.ColumnDoesNotExistError;
Database.cs (118) : return false;
Database.cs (119) : }
Database.cs (120) : table.DeleteWhere(columnCondition);
Database.cs (121) : LastErrorMessage = Constants.DeleteSuccess;
Database.cs (122) : return true;
Database.cs (123) : }
Database.cs (124) : /*
Database.cs (132) : Table table = TableByName(tableName);
Database.cs (133) : if (table == null)
Database.cs (134) : {
Database.cs (135) : LastErrorMessage = Constants.TableDoesNotExistError;
Database.cs (137) : }
Database.cs (139) : if (columnCondition != null &&
Database.cs (140) : table.ColumnIndexByName(columnCondition.ColumnName) == -1)
Database.cs (141) : {
Database.cs (142) : LastErrorMessage = Constants.ColumnDoesNotExistError;
Database.cs (143) : return false;
Database.cs (145) : foreach (var sv in columnNames)
Database.cs (146) : {
Database.cs (147) : if (table.ColumnIndexByName(sv.ColumnName) == -1)
Database.cs (148) : {
Database.cs (149) : LastErrorMessage = Constants.ColumnDoesNotExistError;
Database.cs (150) : return false;
Database.cs (151) : }
Database.cs (152) : }
Database.cs (153) : bool updated = table.Update(columnNames, columnCondition);
Database.cs (155) : if (!updated)
Database.cs (156) : {
Database.cs (158) : LastErrorMessage = Constants.ColumnDoesNotExistError;
Database.cs (160) : }
Database.cs (163) : LastErrorMessage = Constants.UpdateSuccess;
Database.cs (164) : return true;
Database.cs (166) : */
Row.cs (89) : //TODO DEADLINE 1.C: Decode the value doing the opposite of Encode
Row.cs (90) : if (value == null)
Row.cs (93) : return value.Replace(DelimiterEncoded, Delimiter);
Table.cs (28) : ColumnDefinitions = new List<ColumnDefinition>();
Table.cs (29) : Rows = new List<Row>();
Table.cs (54) : if (i >= 0 && i < ColumnDefinitions.Count)
Table.cs (55) : {
Table.cs (58) : return null;
Table.cs (60) : }
Table.cs (87) : /*
Table.cs (88) : public override string ToString() //naroa
Table.cs (100) : //TODO DEADLINE 1.A: Return the table as a string. The format is specified in the documentation
Table.cs (101) : //Valid examples:
Table.cs (102) : //"['Name']{'Adolfo'}{'Jacinto'}" <- one column, two rows
Table.cs (103) : //"['Name','Age']{'Adolfo','23'}{'Jacinto','24'}" <- two columns, two rows
Table.cs (104) : //"" <- no columns, no rows
Table.cs (105) : //"['Name']" <- one column, no rows
Table.cs (108) : if (ColumnDefinitions.Count == 0)
Table.cs (109) : return "";
Table.cs (111) : string result = "[";
Table.cs (112) : for (int i = 0; i < ColumnDefinitions.Count; i++)
Table.cs (113) : {
Table.cs (114) : result += $"'{ColumnDefinitions[i].Name}'";
Table.cs (115) : if (i < ColumnDefinitions.Count - 1)
Table.cs (116) : result += ",";
Table.cs (118) : result += "]";
Table.cs (120) : foreach (var row in Rows)
Table.cs (121) : {
Table.cs (122) : result += "{";
Table.cs (123) : for (int i = 0; i < row.Values.Count; i++)
Table.cs (124) : {
Table.cs (125) : result += $"'{row.Values[i]}'";
Table.cs (126) : if (i < row.Values.Count - 1)
Table.cs (127) : result += ",";
Table.cs (128) : }
Table.cs (129) : result += "}";
Table.cs (130) : }
Table.cs (132) : return result;
Table.cs (133) : }
Table.cs (134) : */
Table.cs (162) : var indices = RowIndicesWhereConditionIsTrue(condition);
Table.cs (163) : indices.Sort((a, b) => b.CompareTo(a));
Table.cs (165) : foreach (var index in indices)
Table.cs (166) : {
Table.cs (167) : DeleteIthRow(index);
Table.cs (168) : }
Table.cs (254) : /*
Table.cs (261) : */
