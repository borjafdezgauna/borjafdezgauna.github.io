Condition.cs (18) : ColumnName = column;
Condition.cs (19) : Operator = op;
Condition.cs (20) : LiteralValue = literalValue;
Condition.cs (33) : switch (type)
Condition.cs (34) : {
Condition.cs (35) : case ColumnDefinition.DataType.String:
Condition.cs (36) : return ComparaStrings(value, LiteralValue);
Condition.cs (38) : case ColumnDefinition.DataType.Int:
Condition.cs (39) : int intValue = int.Parse(value, CultureInfo.InvariantCulture);
Condition.cs (40) : int intLiteral = int.Parse(LiteralValue, CultureInfo.InvariantCulture);
Condition.cs (41) : return ComparaNumeros(intValue, intLiteral);
Condition.cs (43) : case ColumnDefinition.DataType.Double:
Condition.cs (44) : double doubleValue = double.Parse(value, CultureInfo.InvariantCulture);
Condition.cs (45) : double doubleLiteral = double.Parse(LiteralValue, CultureInfo.InvariantCulture);
Condition.cs (46) : return ComparaNumeros(doubleValue, doubleLiteral);
Condition.cs (48) : default:
Condition.cs (50) : }
Condition.cs (52) : }
Condition.cs (54) : private bool ComparaStrings(string a, string b)
Condition.cs (55) : {
Condition.cs (56) : int cmp = string.Compare(a, b, StringComparison.Ordinal);
Condition.cs (58) : return Operator switch
Condition.cs (59) : {
Condition.cs (60) : "="  => cmp == 0,
Condition.cs (61) : "!=" => cmp != 0,
Condition.cs (62) : "<"  => cmp < 0,
Condition.cs (63) : "<=" => cmp <= 0,
Condition.cs (64) : ">"  => cmp > 0,
Condition.cs (65) : ">=" => cmp >= 0,
Condition.cs (66) : _ => false
Condition.cs (67) : };
Condition.cs (70) : private bool ComparaNumeros<T>(T a, T b) where T : IComparable<T>
Condition.cs (71) : {
Condition.cs (72) : int cmp = a.CompareTo(b);
Condition.cs (74) : return Operator switch
Condition.cs (75) : {
Condition.cs (76) : "="  => cmp == 0,
Condition.cs (77) : "!=" => cmp != 0,
Condition.cs (78) : "<"  => cmp < 0,
Condition.cs (79) : "<=" => cmp <= 0,
Condition.cs (80) : ">"  => cmp > 0,
Condition.cs (81) : ">=" => cmp >= 0,
Condition.cs (82) : _ => false
Condition.cs (83) : };
Condition.cs (84) : }
Table.cs (14) : // public Table(string name, List<ColumnDefinition> columns)
Table.cs (15) : // {
Table.cs (16) : //     //TODO DEADLINE 1.A: Initialize member variables
Table.cs (17) : //     this.Name = name;
Table.cs (18) : //     this.ColumnDefinitions = columns;
Table.cs (19) : //     Rows = new List<Row>();
Table.cs (20) : // }
Table.cs (25) : this.ColumnDefinitions = columns ?? new List<ColumnDefinition>();  // <- asegurar que no sea null
Table.cs (26) : this.Rows = new List<Row>();
Table.cs (43) : if (i < 0 || i >= Rows.Count) return null;
Table.cs (76) : // public ColumnDefinition ColumnByName(string column)
Table.cs (77) : // {
Table.cs (78) : //     if (column == null) return null;
Table.cs (80) : //     // foreach (var col in ColumnDefinitions)
Table.cs (81) : //     // {
Table.cs (82) : //     //     if (string.Equals(col.Name, column, StringComparison.OrdinalIgnoreCase))
Table.cs (83) : //     //         return col;
Table.cs (84) : //     // }
Table.cs (85) : //     foreach (var col in ColumnDefinitions)
Table.cs (86) : //     {
Table.cs (87) : //         Console.WriteLine("DEBUG COLUMN: " + col.Name);
Table.cs (88) : //     }
Table.cs (90) : //     return null;
Table.cs (91) : // }
Table.cs (92) : public ColumnDefinition ColumnByName(string name)
Table.cs (112) : int index = ColumnIndexByName(name);
Table.cs (113) : if (index == -1) return null;
Table.cs (114) : return ColumnDefinitions[index];
Table.cs (117) : // public int ColumnIndexByName(string columnName)
Table.cs (118) : // {
Table.cs (119) : //     //TODO DEADLINE 1.A: Return the zero-based index of the column named columnName
Table.cs (120) : //     if (columnName == null) return -1;
Table.cs (122) : //     for (int i = 0; i < ColumnDefinitions.Count; i++)
Table.cs (123) : //     {
Table.cs (124) : //         if (string.Equals(ColumnDefinitions[i].Name, columnName, StringComparison.OrdinalIgnoreCase))
Table.cs (125) : //             return i;
Table.cs (126) : //     }
Table.cs (128) : //     return -1;
Table.cs (129) : // }
Table.cs (130) : public int ColumnIndexByName(string name)
Table.cs (132) : if (string.IsNullOrEmpty(name)) return -1;
Table.cs (136) : var colName = ColumnDefinitions[i].Name;
Table.cs (137) : if (!string.IsNullOrEmpty(colName) && colName.Equals(name, StringComparison.OrdinalIgnoreCase))
Table.cs (167) : // public void DeleteIthRow(int row)
Table.cs (168) : // {
Table.cs (169) : //     //TODO DEADLINE 1.A: Delete the i-th row. If there is no i-th row, do nothing
Table.cs (170) : //     for (int i=0; i<Rows.Count; i++)
Table.cs (171) : //     {
Table.cs (172) : //         if (row == i)
Table.cs (173) : //         {
Table.cs (174) : //             Rows[i] = null;
Table.cs (175) : //         }
Table.cs (176) : //     }
Table.cs (177) : // }
Table.cs (179) : public void DeleteIthRow(int index)
Table.cs (183) : if (index >= 0 && index < Rows.Count)
Table.cs (188) : Rows.RemoveAt(index);
Table.cs (216) : var listaIndices = new List<int>();
Table.cs (218) : for (int i=0; i<Rows.Count; i++)
Table.cs (219) : {
Table.cs (220) : if (Rows[i] == null) continue;
Table.cs (221) : if (condition == null || Rows[i].IsTrue(condition))
Table.cs (222) : {
Table.cs (223) : listaIndices.Add(i);
Table.cs (224) : }
Table.cs (225) : }
Table.cs (226) : return listaIndices;
Table.cs (290) : // public bool Insert(List<string> values)
Table.cs (291) : // {
Table.cs (292) : //     //TODO DEADLINE 1.A: Insert a new row with the values given. If the number of values is not correct, return false. True otherwise
Table.cs (294) : //     return false;
Table.cs (296) : // }
Table.cs (309) : if (values == null) return false;
Table.cs (311) : if (values.Count != ColumnDefinitions.Count)
Table.cs (314) : Row newRow = new Row(ColumnDefinitions, values);
Table.cs (315) : Rows.Add(newRow);
Table.cs (317) : return true;
