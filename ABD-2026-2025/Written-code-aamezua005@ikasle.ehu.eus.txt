Condition.cs (18) : ColumnName = column;
Condition.cs (19) : Operator = op;
Condition.cs (20) : LiteralValue = literalValue;
Condition.cs (32) : switch (type)
Condition.cs (33) : {
Condition.cs (34) : case ColumnDefinition.DataType.String:
Condition.cs (35) : return ComparaStrings(value, LiteralValue);
Condition.cs (37) : case ColumnDefinition.DataType.Int:
Condition.cs (38) : int intValue = int.Parse(value, CultureInfo.InvariantCulture);
Condition.cs (39) : int intLiteral = int.Parse(LiteralValue, CultureInfo.InvariantCulture);
Condition.cs (40) : return ComparaNumeros(intValue, intLiteral);
Condition.cs (42) : case ColumnDefinition.DataType.Double:
Condition.cs (43) : double doubleValue = double.Parse(value, CultureInfo.InvariantCulture);
Condition.cs (44) : double doubleLiteral = double.Parse(LiteralValue, CultureInfo.InvariantCulture);
Condition.cs (45) : return ComparaNumeros(doubleValue, doubleLiteral);
Condition.cs (47) : default:
Condition.cs (49) : }
Condition.cs (51) : }
Condition.cs (53) : private bool ComparaStrings(string a, string b)
Condition.cs (54) : {
Condition.cs (55) : int cmp = string.Compare(a, b, StringComparison.Ordinal);
Condition.cs (57) : return Operator switch
Condition.cs (58) : {
Condition.cs (59) : "="  => cmp == 0,
Condition.cs (60) : "!=" => cmp != 0,
Condition.cs (61) : "<"  => cmp < 0,
Condition.cs (62) : "<=" => cmp <= 0,
Condition.cs (63) : ">"  => cmp > 0,
Condition.cs (64) : ">=" => cmp >= 0,
Condition.cs (65) : _ => false
Condition.cs (66) : };
Condition.cs (69) : private bool ComparaNumeros<T>(T a, T b) where T : IComparable<T>
Condition.cs (70) : {
Condition.cs (71) : int cmp = a.CompareTo(b);
Condition.cs (73) : return Operator switch
Condition.cs (74) : {
Condition.cs (75) : "="  => cmp == 0,
Condition.cs (76) : "!=" => cmp != 0,
Condition.cs (77) : "<"  => cmp < 0,
Condition.cs (78) : "<=" => cmp <= 0,
Condition.cs (79) : ">"  => cmp > 0,
Condition.cs (80) : ">=" => cmp >= 0,
Condition.cs (81) : _ => false
Condition.cs (82) : };
Condition.cs (83) : }
Table.cs (20) : this.ColumnDefinitions = columns ?? new List<ColumnDefinition>();  // <- asegurar que no sea null
Table.cs (21) : this.Rows = new List<Row>();
Table.cs (33) : if (i < 0 || i >= Rows.Count) return null;
Table.cs (61) : public ColumnDefinition ColumnByName(string name)
Table.cs (63) : int index = ColumnIndexByName(name);
Table.cs (64) : if (index == -1) return null;
Table.cs (65) : return ColumnDefinitions[index];
Table.cs (68) : public int ColumnIndexByName(string name)
Table.cs (71) : if (string.IsNullOrEmpty(name)) return -1;
Table.cs (74) : var colName = ColumnDefinitions[i].Name;
Table.cs (75) : if (!string.IsNullOrEmpty(colName) && colName.Equals(name, StringComparison.OrdinalIgnoreCase))
Table.cs (96) : public void DeleteIthRow(int index)
Table.cs (98) : if (index >= 0 && index < Rows.Count)
Table.cs (100) : Rows.RemoveAt(index);
Table.cs (107) : var listaIndices = new List<int>();
Table.cs (109) : for (int i = 0; i < Rows.Count; i++)
Table.cs (110) : {
Table.cs (111) : if (Rows[i] == null) continue;
Table.cs (112) : if (condition == null || Rows[i].IsTrue(condition))
Table.cs (113) : {
Table.cs (114) : listaIndices.Add(i);
Table.cs (115) : }
Table.cs (116) : }
Table.cs (117) : return listaIndices;
Table.cs (204) : return true;
