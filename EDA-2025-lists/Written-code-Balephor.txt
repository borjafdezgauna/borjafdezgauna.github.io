IntArrayList.cs (3) : using System.Reflection.Metadata;
IntArrayList.cs (4) : using System.Security.Principal;
IntArrayList.cs (37) : return NumElements;
IntArrayList.cs (46) : if (index >= Count() || index < 0)
IntArrayList.cs (47) : {
IntArrayList.cs (49) : }
IntArrayList.cs (50) : return Values[index];
IntArrayList.cs (60) : if(NumElements == Values.Length)
IntArrayList.cs (61) : {
IntArrayList.cs (62) : Resize(NumElements * 2);
IntArrayList.cs (63) : }
IntArrayList.cs (64) : Values[NumElements] = value;
IntArrayList.cs (65) : NumElements++;
IntArrayList.cs (72) : if (index < 0 || index >= NumElements)
IntArrayList.cs (73) : {
IntArrayList.cs (74) : return -1;
IntArrayList.cs (75) : }
IntArrayList.cs (77) : int removed = Values[index];
IntArrayList.cs (79) : // Mueve los elementos hacia la izquierda
IntArrayList.cs (80) : for (int i = index; i < NumElements - 1; i++)
IntArrayList.cs (81) : {
IntArrayList.cs (82) : Values[i] = Values[i + 1];
IntArrayList.cs (83) : }
IntArrayList.cs (85) : // Opcional: limpia el Ãºltimo espacio
IntArrayList.cs (86) : Values[NumElements - 1] = 0;
IntArrayList.cs (88) : NumElements--;
IntArrayList.cs (89) : return removed;
IntArrayList.cs (96) : NumElements = 0;
IntArrayList.cs (103) : if (newSize <= Values.Length)
IntArrayList.cs (104) : {
IntArrayList.cs (105) : return;
IntArrayList.cs (106) : }
IntArrayList.cs (109) : int[] newIntArrayList = new int[newSize];
IntArrayList.cs (111) : for (int i = 0, j = 0; i < Values.Length; i++)
IntArrayList.cs (112) : {
IntArrayList.cs (113) : newIntArrayList[j] = Values[i];
IntArrayList.cs (114) : j++;
IntArrayList.cs (115) : }
IntArrayList.cs (117) : Values = newIntArrayList;
IntArrayList.cs (126) : for(int i = 0; i<NumElements; i++)
IntArrayList.cs (127) : {
IntArrayList.cs (128) : yield return Values[i];
IntArrayList.cs (129) : }
IntList.cs (3) : using System.Security.Principal;
IntList.cs (4) : using System.Threading;
IntList.cs (5) : using Microsoft.VisualBasic;
IntList.cs (45) : IntListNode Node = First;
IntList.cs (46) : int count = 0;
IntList.cs (47) : while (Node != null)
IntList.cs (48) : {
IntList.cs (49) : count++;
IntList.cs (50) : Node = Node.Next;
IntList.cs (51) : }
IntList.cs (53) : return count;
IntList.cs (63) : IntListNode Node = First;
IntList.cs (64) : int i = 0;
IntList.cs (65) : if (First == null)
IntList.cs (66) : {
IntList.cs (67) : return 0;
IntList.cs (68) : }
IntList.cs (69) : while (Node != null)
IntList.cs (70) : {
IntList.cs (71) : if (i == index)
IntList.cs (72) : {
IntList.cs (73) : return Node.Value;
IntList.cs (74) : }
IntList.cs (75) : i++;
IntList.cs (76) : Node = Node.Next;
IntList.cs (77) : }
IntList.cs (78) : return 0;
IntList.cs (87) : if(First == null)
IntList.cs (88) : {
IntList.cs (89) : First = new IntListNode(value);
IntList.cs (90) : return;
IntList.cs (91) : }
IntList.cs (93) : IntListNode node = First;
IntList.cs (96) : while (node.Next != null)
IntList.cs (97) : {
IntList.cs (98) : node = node.Next;
IntList.cs (99) : }
IntList.cs (101) : IntListNode last = node;
IntList.cs (102) : IntListNode newNode = new IntListNode(value);
IntList.cs (103) : last.Next = newNode;
IntList.cs (116) : //Si la lista esta vacia
IntList.cs (117) : if (First == null)
IntList.cs (118) : {
IntList.cs (119) : return -1;
IntList.cs (120) : }
IntList.cs (123) : //Si es el primer elemento el que se quiere eliminar y es el unico
IntList.cs (125) : IntListNode node = First;
IntList.cs (127) : if (index == 0 && node.Next == null)
IntList.cs (128) : {
IntList.cs (129) : int removedNum = node.Value;
IntList.cs (130) : First = null;
IntList.cs (131) : return removedNum;
IntList.cs (132) : }
IntList.cs (135) : //si es el primeer elemento el que se quiere eliminar y no es el unico
IntList.cs (137) : if (index == 0 && node.Next != null)
IntList.cs (138) : {
IntList.cs (139) : int removedNum = node.Value;
IntList.cs (140) : First = node.Next;
IntList.cs (141) : return removedNum;
IntList.cs (142) : }
IntList.cs (144) : //Moverse hasta el nodo anterior al que se quiere eliminar
IntList.cs (145) : int i = 0;
IntList.cs (146) : while (node != null && i < index - 1)
IntList.cs (147) : {
IntList.cs (148) : node = node.Next;
IntList.cs (149) : i++;
IntList.cs (150) : }
IntList.cs (152) : //Si el nodo es nulo o el siguiente es nulo
IntList.cs (153) : if (node == null || node.Next == null)
IntList.cs (154) : {
IntList.cs (155) : return -1;
IntList.cs (156) : }
IntList.cs (158) : int removedValue = node.Next.Value;
IntList.cs (159) : node.Next = node.Next.Next;
IntList.cs (160) : return removedValue;
IntList.cs (168) : IntListNode node = First;
IntList.cs (169) : First = null;
IntList.cs (177) : IntListNode node = First;
IntList.cs (178) : int lenght = Count();
IntList.cs (179) : for (int i = 1; i < lenght; i++)
IntList.cs (180) : {
IntList.cs (181) : yield return node.Value;
IntList.cs (182) : node = node.Next;
IntList.cs (183) : }
List.cs (3) : using System.Data;
List.cs (4) : using System.Globalization;
List.cs (5) : using System.Reflection;
List.cs (6) : using System.Runtime.InteropServices;
List.cs (7) : using System.Xml;
List.cs (51) : return m_numItems;
List.cs (59) : ListNode<T> node = First;
List.cs (61) : if (First == null || index < 0 || index >= m_numItems)
List.cs (62) : {
List.cs (63) : return default(T);
List.cs (64) : }
List.cs (66) : for (int i = 0; i < m_numItems; i++)
List.cs (67) : {
List.cs (68) : if (i == index)
List.cs (69) : {
List.cs (70) : return node.Value;
List.cs (71) : }
List.cs (72) : node = node.Next;
List.cs (73) : }
List.cs (85) : //Guardamos value en newNode
List.cs (86) : ListNode<T> newNode = new ListNode<T>(value);
List.cs (88) : //Si esta vacio
List.cs (89) : if (First == null)
List.cs (90) : {
List.cs (91) : First = newNode;
List.cs (92) : Last = newNode;
List.cs (93) : }
List.cs (94) : //si hay un First
List.cs (95) : else
List.cs (96) : {
List.cs (97) : Last.Next = newNode;
List.cs (98) : Last = newNode;
List.cs (99) : }
List.cs (100) : m_numItems++;
List.cs (109) : //Si esta vacio o index esta "out of bounds"
List.cs (110) : if (First == null || index < 0 || index >= m_numItems)
List.cs (111) : {
List.cs (112) : return default(T);
List.cs (113) : }
List.cs (115) : ListNode<T> node = First;
List.cs (116) : T removedVariable = default(T);
List.cs (118) : //Si se quiere eleminar el primer nodo
List.cs (119) : if (index == 0)
List.cs (120) : {
List.cs (121) : // Y es el unico
List.cs (122) : if (First == Last)
List.cs (123) : {
List.cs (124) : removedVariable = node.Value;
List.cs (125) : First = null;
List.cs (126) : Last = null;
List.cs (127) : m_numItems--;
List.cs (128) : return removedVariable;
List.cs (129) : }
List.cs (130) : //No es el Unico
List.cs (131) : removedVariable = node.Value;
List.cs (132) : First = node.Next;
List.cs (133) : m_numItems--;
List.cs (134) : return removedVariable;
List.cs (135) : }
List.cs (136) : //Si se quiere eleminar el ultimo nodo
List.cs (137) : if (index == m_numItems - 1)
List.cs (138) : {
List.cs (139) : for (int i = 0; i < m_numItems; i++)
List.cs (140) : {
List.cs (141) : if (node.Next.Next == null)
List.cs (142) : {
List.cs (143) : removedVariable = node.Next.Value;
List.cs (144) : Last = node;
List.cs (145) : m_numItems--;
List.cs (146) : return removedVariable;
List.cs (147) : }
List.cs (148) : node = node.Next;
List.cs (149) : }
List.cs (150) : }
List.cs (152) : //Si eleminamos una que no es no la primera ni la ultima
List.cs (153) : for(int i = 0; i<m_numItems;i++)
List.cs (154) : {
List.cs (155) : if(i == index-1)
List.cs (156) : {
List.cs (157) : removedVariable = node.Next.Value;
List.cs (158) : node.Next = node.Next.Next;
List.cs (159) : m_numItems--;
List.cs (160) : return removedVariable;
List.cs (161) : }
List.cs (162) : }
List.cs (164) : return default(T);
List.cs (166) : /*
List.cs (168) : int i = 0;
List.cs (169) : while (node != null && i < index - 1)
List.cs (170) : {
List.cs (171) : node = node.Next;
List.cs (172) : i++;
List.cs (173) : }
List.cs (175) : if (node == null || node.Next == null)
List.cs (176) : {
List.cs (178) : }
List.cs (180) : removedVariable = node.Next.Value;
List.cs (181) : node.Next = node.Next.Next;
List.cs (182) : if (node.Next == null) Last = node;
List.cs (183) : m_numItems--;
List.cs (184) : return removedVariable;
List.cs (185) : */
List.cs (191) : m_numItems = 0;
List.cs (192) : First = null;
List.cs (193) : Last = null;
List.cs (200) : ListNode<T> node = First;
List.cs (201) : while (node != null)
List.cs (202) : {
List.cs (203) : yield return node.Value;
List.cs (204) : node = node.Next;
List.cs (205) : }
