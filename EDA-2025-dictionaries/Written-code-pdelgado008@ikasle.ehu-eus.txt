DictionaryReaderWriter.cs (27) : //DESDE AQUI
DictionaryReaderWriter.cs (28) : foreach(var pair in dictionary)
DictionaryReaderWriter.cs (29) : {
DictionaryReaderWriter.cs (30) : String key = EncodeString(keyToString(pair.Key));
DictionaryReaderWriter.cs (31) : String value = EncodeString(valueToString(pair.Value));
DictionaryReaderWriter.cs (33) : writer.WriteLine(key);
DictionaryReaderWriter.cs (35) : writer.WriteLine(value);
DictionaryReaderWriter.cs (36) : }
DictionaryReaderWriter.cs (37) : //HASTA AQUI
DictionaryReaderWriter.cs (56) : //DESDE AQUI
DictionaryReaderWriter.cs (57) : while(true)
DictionaryReaderWriter.cs (58) : {
DictionaryReaderWriter.cs (59) : //para leer una linea de la key
DictionaryReaderWriter.cs (60) : lineaKey=reader.ReadLine();
DictionaryReaderWriter.cs (61) : //para leet una linea del value
DictionaryReaderWriter.cs (62) : lineaValue=reader.ReadLine();
DictionaryReaderWriter.cs (64) : TKey key=stringToKey(DecodeString(lineaKey));
DictionaryReaderWriter.cs (65) : TValue value = valueToKey(DecodeString(lineaValue));
DictionaryReaderWriter.cs (67) : //para añadirlo al diccionario
DictionaryReaderWriter.cs (68) : dictionary[key]=value;
DictionaryReaderWriter.cs (70) : }
DictionaryReaderWriter.cs (71) : //HASTA AQUI
HashTableDictionary.cs (12) : //HE COPIADO LA CLASE DE LIST (generica) PERO NO SE SI ESTÁ BIEN AQUÍ
HashTableDictionary.cs (13) : public class ListNode<T>
HashTableDictionary.cs (14) : {
HashTableDictionary.cs (15) : public T Value;
HashTableDictionary.cs (16) : public ListNode<T> Next = null;
HashTableDictionary.cs (17) : public ListNode<T> Previous = null;
HashTableDictionary.cs (20) : public ListNode(T value)
HashTableDictionary.cs (21) : {
HashTableDictionary.cs (22) : Value = value;
HashTableDictionary.cs (23) : }
HashTableDictionary.cs (25) : public override string ToString()
HashTableDictionary.cs (26) : {
HashTableDictionary.cs (27) : return Value.ToString();
HashTableDictionary.cs (28) : }
HashTableDictionary.cs (29) : }
HashTableDictionary.cs (31) : public class List<T> : IList<T>
HashTableDictionary.cs (32) : {
HashTableDictionary.cs (33) : ListNode<T> First = null;
HashTableDictionary.cs (34) : ListNode<T> Last = null;
HashTableDictionary.cs (36) : int m_numItems = 0;
HashTableDictionary.cs (38) : public override string ToString()
HashTableDictionary.cs (39) : {
HashTableDictionary.cs (40) : ListNode<T> node = First;
HashTableDictionary.cs (41) : string output = "[";
HashTableDictionary.cs (43) : while (node != null)
HashTableDictionary.cs (44) : {
HashTableDictionary.cs (45) : output += node.ToString() + ",";
HashTableDictionary.cs (46) : node = node.Next;
HashTableDictionary.cs (47) : }
HashTableDictionary.cs (48) : output = output.TrimEnd(',') + "] " + Count() + " elements";
HashTableDictionary.cs (50) : return output;
HashTableDictionary.cs (51) : }
HashTableDictionary.cs (53) : public int Count()
HashTableDictionary.cs (54) : {
HashTableDictionary.cs (55) : //TODO #1: return the number of elements on the list
HashTableDictionary.cs (57) : return m_numItems;
HashTableDictionary.cs (59) : }
HashTableDictionary.cs (61) : public T Get(int index)
HashTableDictionary.cs (62) : {
HashTableDictionary.cs (63) : //TODO #2: return the element on the index-th position. O if the position is out of bounds
HashTableDictionary.cs (65) : if(index < 0 || index >= Count())
HashTableDictionary.cs (66) : {
HashTableDictionary.cs (67) : return default(T);
HashTableDictionary.cs (68) : }
HashTableDictionary.cs (70) : ListNode<T> node = First;
HashTableDictionary.cs (71) : int i= 0;
HashTableDictionary.cs (72) : while(i < index)
HashTableDictionary.cs (73) : {
HashTableDictionary.cs (74) : node = node.Next;
HashTableDictionary.cs (75) : i++;
HashTableDictionary.cs (76) : }
HashTableDictionary.cs (78) : return node.Value;
HashTableDictionary.cs (80) : }
HashTableDictionary.cs (82) : public void Add(T value)
HashTableDictionary.cs (83) : {
HashTableDictionary.cs (84) : //TODO #3: add a new integer to the end of the list
HashTableDictionary.cs (85) : ListNode<T> node = new ListNode<T>(value);
HashTableDictionary.cs (86) : if (First == null)
HashTableDictionary.cs (87) : {
HashTableDictionary.cs (88) : First = node;
HashTableDictionary.cs (89) : }
HashTableDictionary.cs (90) : else
HashTableDictionary.cs (91) : {
HashTableDictionary.cs (92) : Last.Next = node;
HashTableDictionary.cs (93) : node.Previous = Last;
HashTableDictionary.cs (94) : }
HashTableDictionary.cs (95) : Last = node;
HashTableDictionary.cs (97) : m_numItems++;
HashTableDictionary.cs (98) : }
HashTableDictionary.cs (100) : public T Remove(int index)
HashTableDictionary.cs (101) : {
HashTableDictionary.cs (102) : //TODO #4: remove the element on the index-th position. Do nothing if position is out of bounds
HashTableDictionary.cs (104) : //si estamos fuera de los rangos
HashTableDictionary.cs (105) : if(index < 0 || index >= Count())
HashTableDictionary.cs (106) : {
HashTableDictionary.cs (107) : return default(T);
HashTableDictionary.cs (108) : }
HashTableDictionary.cs (110) : //Si el elemento a eliminar es el primero
HashTableDictionary.cs (111) : if (index == 0)
HashTableDictionary.cs (112) : {
HashTableDictionary.cs (113) : T value1 = First.Value;
HashTableDictionary.cs (114) : First = First.Next;
HashTableDictionary.cs (115) : if (First != null)
HashTableDictionary.cs (116) : {
HashTableDictionary.cs (117) : First.Previous = null;
HashTableDictionary.cs (118) : }
HashTableDictionary.cs (119) : else
HashTableDictionary.cs (120) : {
HashTableDictionary.cs (121) : Last = null;
HashTableDictionary.cs (122) : }
HashTableDictionary.cs (123) : m_numItems--;
HashTableDictionary.cs (124) : return value1;
HashTableDictionary.cs (126) : }
HashTableDictionary.cs (127) : //Si el elemento a eliminar es el último
HashTableDictionary.cs (128) : if (index == Count() - 1)
HashTableDictionary.cs (129) : {
HashTableDictionary.cs (130) : T value2 = Last.Value;
HashTableDictionary.cs (131) : Last = Last.Previous;
HashTableDictionary.cs (132) : if (Last != null)
HashTableDictionary.cs (133) : {
HashTableDictionary.cs (134) : Last.Next = null;
HashTableDictionary.cs (135) : }
HashTableDictionary.cs (136) : else
HashTableDictionary.cs (137) : {
HashTableDictionary.cs (138) : First = null;
HashTableDictionary.cs (139) : }
HashTableDictionary.cs (140) : m_numItems--;
HashTableDictionary.cs (141) : return value2;
HashTableDictionary.cs (142) : }
HashTableDictionary.cs (143) : //Si el elemento a eliminar está en medio
HashTableDictionary.cs (144) : ListNode<T> node = First;
HashTableDictionary.cs (145) : int i = 0;
HashTableDictionary.cs (146) : while (i < index)
HashTableDictionary.cs (147) : {
HashTableDictionary.cs (148) : node = node.Next;
HashTableDictionary.cs (149) : i++;
HashTableDictionary.cs (150) : }
HashTableDictionary.cs (151) : T value = node.Value; //guerdamos el valor de lo que queremos eliminar para devolverlo al final
HashTableDictionary.cs (152) : node.Previous.Next = node.Next; //hacemos que le nodo anterior sea el siguiente del nodo actual
HashTableDictionary.cs (153) : node.Next.Previous = node.Previous; //hacemos que el nodo siguiente sea el anterior del nodo actual
HashTableDictionary.cs (154) : m_numItems--;
HashTableDictionary.cs (155) : return value;
HashTableDictionary.cs (157) : }
HashTableDictionary.cs (159) : public void Clear()
HashTableDictionary.cs (160) : {
HashTableDictionary.cs (161) : //TODO #5: remove all the elements on the list
HashTableDictionary.cs (162) : First = null;
HashTableDictionary.cs (163) : Last = null;
HashTableDictionary.cs (164) : m_numItems = 0;
HashTableDictionary.cs (166) : }
HashTableDictionary.cs (168) : public IEnumerator GetEnumerator()
HashTableDictionary.cs (169) : {
HashTableDictionary.cs (170) : //TODO #6 : Return an enumerator using "yield return" for each of the values in this list
HashTableDictionary.cs (172) : ListNode<T> node = First;
HashTableDictionary.cs (173) : while (node != null)
HashTableDictionary.cs (174) : {
HashTableDictionary.cs (175) : yield return node.Value;
HashTableDictionary.cs (176) : node = node.Next;
HashTableDictionary.cs (177) : }
HashTableDictionary.cs (179) : }
HashTableDictionary.cs (181) : }
HashTableDictionary.cs (182) : //HE AÑADIDO ESTO QUE ES LO QUE PIDE PERO NO SE SI ES AQUI
HashTableDictionary.cs (183) : List<HashTableDictionaryItem<TKey, TValue>>[] Entries;
HashTableDictionary.cs (190) : Entries = new List<HashTableDictionaryItem<TKey, TValue>>[DefaultNumEntries];
HashTableDictionary.cs (197) : Entries = new List<HashTableDictionaryItem<TKey, TValue>>[numEntries];
HashTableDictionary.cs (207) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (208) : {
HashTableDictionary.cs (209) : if (Entries[i] != null)
HashTableDictionary.cs (210) : {
HashTableDictionary.cs (211) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (212) : {
HashTableDictionary.cs (213) : HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (214) : output += entry.ToString();
HashTableDictionary.cs (215) : }
HashTableDictionary.cs (216) : }
HashTableDictionary.cs (217) : }
HashTableDictionary.cs (227) : return NumElements;
HashTableDictionary.cs (236) : int hash= key.GetHashCode();
HashTableDictionary.cs (238) : //para asegurarnos de que está en el rango de Entries, tiene que ser mayor que cero y menos que Entries.Lenght-1
HashTableDictionary.cs (239) : int hashPositivo=Math.Abs(hash);//primero lo devolvemos positivo
HashTableDictionary.cs (240) : int posicion = hashPositivo % Entries.Length; //hacemos que entre dentro del rango establecido
HashTableDictionary.cs (242) : return posicion;
