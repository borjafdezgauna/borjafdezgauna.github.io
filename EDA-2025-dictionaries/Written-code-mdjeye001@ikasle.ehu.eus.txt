BinaryTree.cs (2) : namespace Common
BinaryTree.cs (88) : node.LeftChild = AddBalanced(keys, values, start, mid - 1);
BinaryTree.cs (89) : node.RightChild = AddBalanced(keys, values, mid + 1, end);
BinaryTreeDictionary.cs (1) : using System;
BinaryTreeDictionary.cs (3) : namespace Common;
BinaryTreeDictionary.cs (11) : public BinaryTree<TKey, TValue> Tree;
BinaryTreeDictionary.cs (13) : public BinaryTreeDictionary()
BinaryTreeDictionary.cs (15) : //TODO #2: Initialize anything that needs initialization
BinaryTreeDictionary.cs (16) : Tree=new BinaryTree<TKey, TValue>();
BinaryTreeDictionary.cs (20) : public override string ToString()
BinaryTreeDictionary.cs (22) : //TODO #3: Use the implementation of BinaryTree
BinaryTreeDictionary.cs (23) : return Tree.ToString();
BinaryTreeDictionary.cs (26) : public int Count()
BinaryTreeDictionary.cs (28) : //TODO #4
BinaryTreeDictionary.cs (29) : return Tree.Count();
BinaryTreeDictionary.cs (34) : //TODO #5
BinaryTreeDictionary.cs (35) : try
BinaryTreeDictionary.cs (37) : return Tree.Get(key);
BinaryTreeDictionary.cs (39) : catch (Exception)
BinaryTreeDictionary.cs (40) : when (Tree == null || Tree.RootNode == null)
BinaryTreeDictionary.cs (42) : return default(TValue);
BinaryTreeDictionary.cs (44) : catch (Exception)
BinaryTreeDictionary.cs (46) : return default(TValue);
BinaryTreeDictionary.cs (50) : public void Add(TKey key, TValue value)
BinaryTreeDictionary.cs (51) : {
BinaryTreeDictionary.cs (52) : //TODO #6
BinaryTreeDictionary.cs (53) : Tree.Add(key, value);
BinaryTreeDictionary.cs (57) : public void Remove(TKey key)
BinaryTreeDictionary.cs (59) : //TODO #6: Remove the item with this key.
BinaryTreeDictionary.cs (60) : Tree.Remove(key);
BinaryTreeDictionary.cs (63) : public TKey[] Keys()
BinaryTreeDictionary.cs (65) : //TODO #7: Return an array with all the keys in the dictionary. The length of the array needs to be equal
BinaryTreeDictionary.cs (66) : //to the number of elements in the dictionary
BinaryTreeDictionary.cs (67) : TKey[] l=null;
BinaryTreeDictionary.cs (68) : if (Tree.Count() == null)
BinaryTreeDictionary.cs (70) : l=new TKey[0];
BinaryTreeDictionary.cs (71) : return l;
BinaryTreeDictionary.cs (73) : else
BinaryTreeDictionary.cs (75) : return Tree.Keys();
BinaryTreeDictionary.cs (79) : public TValue[] Values()
BinaryTreeDictionary.cs (81) : //TODO #8: Return an array with all the values in the dictionary. The length of the array needs to be equal
BinaryTreeDictionary.cs (82) : //to the number of elements in the dictionary
BinaryTreeDictionary.cs (83) : TValue[] w=null;
BinaryTreeDictionary.cs (84) : if (Tree.Count() == 0)
BinaryTreeDictionary.cs (85) : {
BinaryTreeDictionary.cs (86) : w=new TValue[0];
BinaryTreeDictionary.cs (87) : return w;
BinaryTreeDictionary.cs (89) : else
BinaryTreeDictionary.cs (91) : return Tree.Values();
BinaryTreeNode.cs (2) : namespace Common
HashTableDictionary.cs (136) : list.Remove(i);
IList.cs (1) : using System;
IList.cs (2) : using System.Collections;
IList.cs (4) : using System.Linq;
IList.cs (5) : using System.Text;
IList.cs (6) : using System.Threading.Tasks;
IList.cs (8) : namespace Common
IList.cs (9) : {
IList.cs (10) : public interface IList<T> : IEnumerable
IList.cs (11) : {
IList.cs (12) : int Count();
IList.cs (14) : T Get(int index);
IList.cs (16) : void Add(T value);
IList.cs (18) : T Remove(int index);
IList.cs (20) : void Clear();
IList.cs (21) : }
IList.cs (22) : }
List.cs (1) : using Common;
List.cs (2) : using System.Collections;
List.cs (4) : public class ListNode<T>
List.cs (5) : {
List.cs (6) : public T Value;
List.cs (7) : public ListNode<T> Next = null;
List.cs (11) : public ListNode(T value)
List.cs (12) : {
List.cs (13) : Value = value;
List.cs (14) : }
List.cs (16) : public override string ToString()
List.cs (17) : {
List.cs (18) : return Value.ToString();
List.cs (19) : }
List.cs (20) : }
List.cs (22) : public class List<T> : IList<T>
List.cs (23) : {
List.cs (24) : ListNode<T> First = null;
List.cs (25) : ListNode<T> Last = null;
List.cs (26) : int m_numItems = 0;
List.cs (28) : public override string ToString()
List.cs (29) : {
List.cs (30) : ListNode<T> node = First;
List.cs (31) : string output = "[";
List.cs (33) : while (node != null)
List.cs (34) : {
List.cs (35) : output += node.ToString() + ",";
List.cs (36) : node = node.Next;
List.cs (37) : }
List.cs (38) : output = output.TrimEnd(',') + "] " + Count() + " elements";
List.cs (40) : return output;
List.cs (41) : }
List.cs (43) : public int Count()
List.cs (44) : {
List.cs (45) : //TODO #1: return the number of elements on the list
List.cs (47) : return m_numItems;
List.cs (49) : }
List.cs (51) : public T Get(int index)
List.cs (52) : {
List.cs (53) : //TODO #2: return the element on the index-th position. O if the position is out of bounds
List.cs (54) : if (index < 0 || index >= m_numItems)
List.cs (55) : {
List.cs (56) : return default(T);
List.cs (57) : }
List.cs (58) : else
List.cs (59) : {
List.cs (60) : int i = 0;
List.cs (61) : ListNode<T> aux = First;
List.cs (62) : while (i < index)
List.cs (63) : {
List.cs (64) : aux = aux.Next;
List.cs (65) : i++;
List.cs (66) : }
List.cs (67) : return aux.Value;
List.cs (68) : }
List.cs (69) : }
List.cs (71) : public void Add(T value)
List.cs (72) : {
List.cs (73) : //TODO #3: add a new integer to the end of the list
List.cs (74) : ListNode<T> node = new ListNode<T>(value);
List.cs (75) : if (First == null)
List.cs (76) : {
List.cs (77) : First = node;
List.cs (78) : Last = node;
List.cs (79) : }
List.cs (80) : else
List.cs (81) : {
List.cs (82) : ListNode<T> aux = First;
List.cs (83) : while (aux.Next != null)
List.cs (84) : {
List.cs (85) : aux = aux.Next;
List.cs (86) : }
List.cs (87) : aux.Next = node;
List.cs (88) : }
List.cs (89) : m_numItems++;
List.cs (90) : }
List.cs (92) : public T Remove(int index)
List.cs (93) : {
List.cs (94) : //TODO #4: remove the element on the index-th position. Do nothing if position is out of bounds
List.cs (95) : if (index < 0 || index >= m_numItems)
List.cs (96) : {
List.cs (97) : return default(T);
List.cs (98) : }
List.cs (99) : else if (index == 0)
List.cs (100) : {
List.cs (101) : T data = First.Value;
List.cs (102) : First = First.Next;
List.cs (103) : m_numItems--;
List.cs (104) : return data;
List.cs (105) : }
List.cs (106) : else
List.cs (107) : {
List.cs (108) : ListNode<T> aux = First;
List.cs (109) : int a = 0;
List.cs (110) : while (a < index - 1)
List.cs (111) : {
List.cs (112) : aux = aux.Next;
List.cs (113) : a++;
List.cs (114) : }
List.cs (115) : T data = aux.Next.Value;
List.cs (116) : aux.Next = aux.Next.Next;
List.cs (117) : if (index == m_numItems - 1)
List.cs (118) : {
List.cs (119) : Last = aux;
List.cs (120) : }
List.cs (121) : m_numItems--;
List.cs (122) : return data;
List.cs (123) : }
List.cs (124) : }
List.cs (126) : public void Clear()
List.cs (127) : {
List.cs (128) : //TODO #5: remove all the elements on the list
List.cs (129) : m_numItems = 0;
List.cs (130) : First = null;
List.cs (131) : Last = null;
List.cs (132) : }
List.cs (134) : public IEnumerator GetEnumerator()
List.cs (135) : {
List.cs (136) : //TODO #6 : Return an enumerator using "yield return" for each of the values in this list
List.cs (137) : ListNode<T> node = First;
List.cs (138) : while (node != null)
List.cs (139) : {
List.cs (140) : T data = node.Value;
List.cs (141) : node = node.Next;
List.cs (142) : yield return data;
List.cs (143) : }
List.cs (144) : }
List.cs (145) : }
