BinaryTreeDictionary.cs (2) : using System;
BinaryTreeDictionary.cs (6) : public class BinaryTreeDictionary<TKey, TValue> : Common.IDictionary<TKey, TValue> where TKey : IComparable<TKey>
BinaryTreeDictionary.cs (7) : {
BinaryTreeDictionary.cs (8) : //TODO #1: Add your implementation of BinaryTree/BinaryTreeNode to the project
BinaryTreeDictionary.cs (9) : //         BinaryTreeDictionary and declare the tree we will use in this class:
BinaryTreeDictionary.cs (10) : //
BinaryTreeDictionary.cs (11) : //public [USE BinaryTree HERE] Tree;
BinaryTreeDictionary.cs (14) : public BinaryTreeDictionary()
BinaryTreeDictionary.cs (15) : {
BinaryTreeDictionary.cs (16) : //TODO #2: Initialize anything that needs initialization
BinaryTreeDictionary.cs (18) : }
BinaryTreeDictionary.cs (20) : public override string ToString()
BinaryTreeDictionary.cs (21) : {
BinaryTreeDictionary.cs (22) : //TODO #3: Use the implementation of BinaryTree
BinaryTreeDictionary.cs (24) : return null;
BinaryTreeDictionary.cs (26) : }
BinaryTreeDictionary.cs (28) : public int Count()
BinaryTreeDictionary.cs (29) : {
BinaryTreeDictionary.cs (30) : //TODO #4
BinaryTreeDictionary.cs (32) : return 0;
BinaryTreeDictionary.cs (34) : }
BinaryTreeDictionary.cs (36) : public TValue Get(TKey key)
BinaryTreeDictionary.cs (37) : {
BinaryTreeDictionary.cs (38) : //TODO #5
BinaryTreeDictionary.cs (40) : return default(TValue);
BinaryTreeDictionary.cs (42) : }
BinaryTreeDictionary.cs (44) : public void Add(TKey key, TValue value)
BinaryTreeDictionary.cs (45) : {
BinaryTreeDictionary.cs (46) : //TODO #6
BinaryTreeDictionary.cs (48) : }
BinaryTreeDictionary.cs (50) : public void Remove(TKey key)
BinaryTreeDictionary.cs (51) : {
BinaryTreeDictionary.cs (52) : //TODO #6: Remove the item with this key.
BinaryTreeDictionary.cs (54) : }
BinaryTreeDictionary.cs (56) : public TKey[] Keys()
BinaryTreeDictionary.cs (57) : {
BinaryTreeDictionary.cs (58) : //TODO #7: Return an array with all the keys in the dictionary. The length of the array needs to be equal
BinaryTreeDictionary.cs (59) : //to the number of elements in the dictionary
BinaryTreeDictionary.cs (61) : return null;
BinaryTreeDictionary.cs (63) : }
BinaryTreeDictionary.cs (65) : public TValue[] Values()
BinaryTreeDictionary.cs (66) : {
BinaryTreeDictionary.cs (67) : //TODO #8: Return an array with all the values in the dictionary. The length of the array needs to be equal
BinaryTreeDictionary.cs (68) : //to the number of elements in the dictionary
BinaryTreeDictionary.cs (70) : return null;
BinaryTreeDictionary.cs (72) : }
BinaryTreeDictionary.cs (73) : }
main.cs (1) : using Common;
main.cs (2) : using System;
main.cs (3) : using System.Diagnostics;
main.cs (4) : using System.Reflection;
main.cs (6) : class MainClass
main.cs (7) : {
main.cs (8) : public static void Main(string[] args)
main.cs (9) : {
main.cs (10) : Console.WriteLine("Testing BinaryTreeDictionary<int,string>:\n");
main.cs (12) : bool success = Common.Tests.Test1_AddGetCount(new BinaryTreeDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (13) : if (!success)
main.cs (14) : return;
main.cs (16) : success = Common.Tests.Test2_AddDuplicate(new BinaryTreeDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (17) : if (!success)
main.cs (18) : return;
main.cs (20) : success = Common.Tests.Test3_Remove(new BinaryTreeDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (21) : if (!success)
main.cs (22) : return;
main.cs (24) : success = Common.Tests.Test4_RemoveNonExistent(new BinaryTreeDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (25) : if (!success)
main.cs (26) : return;
main.cs (28) : success = Common.Tests.Test5_KeysValues(new BinaryTreeDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (29) : if (!success)
main.cs (30) : return;
main.cs (32) : success = Tests.TestPerformanceWithTimeout(new BinaryTreeDictionary<int,int>(), Console.WriteLine, Console.WriteLine);
main.cs (33) : if (!success)
main.cs (34) : return;
main.cs (36) : BinaryTreeDictionary<string, int> numbers = new BinaryTreeDictionary<string, int>();
main.cs (37) : success = Common.Tests.TestReaderWriterStringInt(numbers, "numbers-dictionary-bin-tree.txt", Console.WriteLine, Console.WriteLine);
main.cs (38) : if (!success)
main.cs (39) : return;
main.cs (41) : BinaryTreeDictionary<int, double> grades = new BinaryTreeDictionary<int, double>();
main.cs (42) : success = Common.Tests.TestReaderWriterIntDouble(grades, "grades-dictionary-bin-tree.txt", Console.WriteLine, Console.WriteLine);
main.cs (43) : if (!success)
main.cs (44) : return;
main.cs (46) : Console.WriteLine($"All tests passed.");
main.cs (47) : }
main.cs (48) : }
DictionaryReaderWriter.cs (1) : using System;
DictionaryReaderWriter.cs (2) : using System.IO;
DictionaryReaderWriter.cs (3) : using System.Text;
DictionaryReaderWriter.cs (5) : namespace Common
DictionaryReaderWriter.cs (6) : {
DictionaryReaderWriter.cs (7) : public class DictionaryReaderWriter
DictionaryReaderWriter.cs (8) : {
DictionaryReaderWriter.cs (9) : private string EncodeString(string str) => str.Replace("\n", "[NEW_LINE]");
DictionaryReaderWriter.cs (10) : private string DecodeString(string str) => str.Replace("[NEW_LINE]", "\n");
DictionaryReaderWriter.cs (11) : public bool Write<TKey,TValue>(IDictionary<TKey,TValue> dictionary, string filename,
DictionaryReaderWriter.cs (12) : Func<TKey, string> keyToString, Func<TValue, string> valueToString)
DictionaryReaderWriter.cs (13) : {
DictionaryReaderWriter.cs (14) : try
DictionaryReaderWriter.cs (15) : {
DictionaryReaderWriter.cs (16) : TextWriter writer = File.CreateText(filename);
DictionaryReaderWriter.cs (18) : //TODO #1: Write in the file the keys and values, one by one: a key in a line, its value on the following line
DictionaryReaderWriter.cs (19) : //Example: If the dictionary has the key/value pairs 1234->4.25 and 2133->1.35, then the content of the file will be:
DictionaryReaderWriter.cs (20) : //1234
DictionaryReaderWriter.cs (21) : //4.25
DictionaryReaderWriter.cs (22) : //2133
DictionaryReaderWriter.cs (23) : //1.35
DictionaryReaderWriter.cs (24) : //Because we don't know what type keys and values are, we need to call keyToString(key) to convert the key to string and
DictionaryReaderWriter.cs (25) : //valueToString(value) to convert the value to string
DictionaryReaderWriter.cs (28) : writer.Close();
DictionaryReaderWriter.cs (30) : return true;
DictionaryReaderWriter.cs (31) : }
DictionaryReaderWriter.cs (32) : catch { return false; }
DictionaryReaderWriter.cs (33) : }
DictionaryReaderWriter.cs (35) : public bool Read<TKey, TValue>(IDictionary<TKey, TValue> dictionary, string filename,
DictionaryReaderWriter.cs (36) : Func<string,TKey> stringToKey, Func<string,TValue> valueToKey)
DictionaryReaderWriter.cs (37) : {
DictionaryReaderWriter.cs (38) : try
DictionaryReaderWriter.cs (39) : {
DictionaryReaderWriter.cs (40) : TextReader reader = File.OpenText(filename);
DictionaryReaderWriter.cs (42) : //TODO #2: Read the keys and values one by one and add them to the given dictionary. Use the same format as the Write() above
DictionaryReaderWriter.cs (43) : //Once a key is read from the file, it needs to be converted to string using stringToKey(line). For the value, valueToKey(line)
DictionaryReaderWriter.cs (46) : reader.Close();
DictionaryReaderWriter.cs (48) : return true;
DictionaryReaderWriter.cs (49) : }
DictionaryReaderWriter.cs (50) : catch { return false; }
DictionaryReaderWriter.cs (51) : }
DictionaryReaderWriter.cs (52) : }
DictionaryReaderWriter.cs (53) : }
IDictionary.cs (1) : ﻿using System;
IDictionary.cs (2) : using System.Collections.Generic;
IDictionary.cs (3) : using System.Text;
IDictionary.cs (5) : namespace Common
IDictionary.cs (6) : {
IDictionary.cs (7) : public interface IDictionary<TKey,TValue>
IDictionary.cs (8) : {
IDictionary.cs (9) : int Count();
IDictionary.cs (10) : TValue Get(TKey key);
IDictionary.cs (11) : void Add(TKey key, TValue value);
IDictionary.cs (12) : void Remove(TKey key);
IDictionary.cs (13) : public TKey[] Keys();
IDictionary.cs (14) : public TValue[] Values();
IDictionary.cs (15) : }
IDictionary.cs (16) : }
TimeoutHandler.cs (1) : ﻿using System;
TimeoutHandler.cs (2) : using System.Diagnostics;
TimeoutHandler.cs (3) : using System.Text;
TimeoutHandler.cs (4) : using System.Threading.Tasks;
TimeoutHandler.cs (6) : namespace Common
TimeoutHandler.cs (7) : {
TimeoutHandler.cs (9) : public static class TimeoutHandler
TimeoutHandler.cs (10) : {
TimeoutHandler.cs (11) : public static bool Test<T>(Func<T, Action<string>, Action<string>, bool> test, T parameter,
TimeoutHandler.cs (12) : int timeoutSecs, Action<string> onProgress, Action<string> onError)
TimeoutHandler.cs (13) : {
TimeoutHandler.cs (14) : Task timeoutTask = Task.Delay(timeoutSecs * 1000);
TimeoutHandler.cs (15) : Task<bool> testTask = Task.Factory.StartNew(() => test(parameter, onProgress, onError));
TimeoutHandler.cs (17) : var winner = Task.WhenAny(testTask, timeoutTask).Result;
TimeoutHandler.cs (20) : if (testTask.IsCompleted && testTask.Result)
TimeoutHandler.cs (21) : {
TimeoutHandler.cs (22) : onProgress("Success");
TimeoutHandler.cs (23) : return true;
TimeoutHandler.cs (24) : }
TimeoutHandler.cs (25) : else if (testTask.IsCompleted)
TimeoutHandler.cs (26) : {
TimeoutHandler.cs (27) : onError("The test failed");
TimeoutHandler.cs (28) : return false;
TimeoutHandler.cs (29) : }
TimeoutHandler.cs (31) : //This test timed out
TimeoutHandler.cs (32) : onError($"The test took too long and it timed out (>{timeoutSecs}s)");
TimeoutHandler.cs (33) : return false;
TimeoutHandler.cs (34) : }
TimeoutHandler.cs (36) : public static bool Test<T1,T2>(Func<T1, T2, Action<string>, Action<string>, bool> test, T1 parameter1, T2 parameter2,
TimeoutHandler.cs (37) : int timeoutSecs, Action<string> onProgress, Action<string> onError)
TimeoutHandler.cs (38) : {
TimeoutHandler.cs (39) : Task timeoutTask = Task.Delay(timeoutSecs * 1000);
TimeoutHandler.cs (40) : Task<bool> testTask = Task.Factory.StartNew(() => test(parameter1, parameter2, onProgress, onError));
TimeoutHandler.cs (42) : var winner = Task.WhenAny(testTask, timeoutTask).Result;
TimeoutHandler.cs (45) : if (testTask.IsCompleted && testTask.Result)
TimeoutHandler.cs (46) : {
TimeoutHandler.cs (47) : onProgress("Success");
TimeoutHandler.cs (48) : return true;
TimeoutHandler.cs (49) : }
TimeoutHandler.cs (50) : else if (testTask.IsCompleted)
TimeoutHandler.cs (51) : {
TimeoutHandler.cs (52) : onError("The test failed");
TimeoutHandler.cs (53) : return false;
TimeoutHandler.cs (54) : }
TimeoutHandler.cs (56) : //This test timed out
TimeoutHandler.cs (57) : onError($"The test took too long and it timed out (>{timeoutSecs}s)");
TimeoutHandler.cs (58) : return false;
TimeoutHandler.cs (59) : }
TimeoutHandler.cs (60) : }
TimeoutHandler.cs (61) : }
HashTableDictionary.cs (2) : using Common;
HashTableDictionary.cs (3) : using System;
HashTableDictionary.cs (5) : public class HashTableDictionary<TKey, TValue> : IDictionary<TKey, TValue>
HashTableDictionary.cs (6) : {
HashTableDictionary.cs (7) : int DefaultNumEntries = 10000;
HashTableDictionary.cs (8) : int NumElements = 0;
HashTableDictionary.cs (9) : //TODO #1: Copy your implementation of List to the project HashTableDictionary and use it to declare Entries: an array of lists of HashTableDictionaryItem<TKey,TValue>
HashTableDictionary.cs (10) : //[USE List and HashTableDictionaryItem HERE] [] Entries;
HashTableDictionary.cs (14) : public HashTableDictionary()
HashTableDictionary.cs (15) : {
HashTableDictionary.cs (16) : //TODO #2: Initialize Entries with an array of size DefaultNumEntries
HashTableDictionary.cs (18) : }
HashTableDictionary.cs (20) : public HashTableDictionary(int numEntries)
HashTableDictionary.cs (21) : {
HashTableDictionary.cs (22) : //TODO #2: Initialize Entries with a specific number of entries (numEntries)
HashTableDictionary.cs (24) : }
HashTableDictionary.cs (26) : public override string ToString()
HashTableDictionary.cs (27) : {
HashTableDictionary.cs (28) : string output = null;
HashTableDictionary.cs (30) : //TODO #3: Uncomment the code below
HashTableDictionary.cs (32) : //for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (33) : //{
HashTableDictionary.cs (34) : //    if (Entries[i] != null)
HashTableDictionary.cs (35) : //    {
HashTableDictionary.cs (36) : //        for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (37) : //        {
HashTableDictionary.cs (38) : //            HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (39) : //            output += entry.ToString();
HashTableDictionary.cs (40) : //        }
HashTableDictionary.cs (41) : //    }
HashTableDictionary.cs (42) : //}
HashTableDictionary.cs (45) : return output;
HashTableDictionary.cs (46) : }
HashTableDictionary.cs (48) : public int Count()
HashTableDictionary.cs (49) : {
HashTableDictionary.cs (50) : //TODO #4: Return the number of elements (NumElements: make sure this member variable/attribute is updated when the number of elements changes)
HashTableDictionary.cs (52) : return 0;
HashTableDictionary.cs (54) : }
HashTableDictionary.cs (56) : public int PositionOf(TKey key)
HashTableDictionary.cs (57) : {
HashTableDictionary.cs (58) : //TODO #5:  Calculate in which entry should this key be stored and return it (use key.GetHashCode() to calculate the hash function of the key)
HashTableDictionary.cs (59) : //          Note:  GetHashCode() returns very large integer numbers, but we need to map this value to the range [0, Entries.Length-1]
HashTableDictionary.cs (61) : return -1;
HashTableDictionary.cs (63) : }
HashTableDictionary.cs (65) : public TValue Get(TKey key)
HashTableDictionary.cs (66) : {
HashTableDictionary.cs (67) : //TODO #5:  Using PositionOf, calculate where this key should be in the array of entries and, then,
HashTableDictionary.cs (68) : //          find the item with this key on the list, and return its value
HashTableDictionary.cs (70) : return default(TValue);
HashTableDictionary.cs (71) : }
HashTableDictionary.cs (73) : public void Add(TKey key, TValue value)
HashTableDictionary.cs (74) : {
HashTableDictionary.cs (75) : //TODO #5:  Using PositionOf, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (76) : //          - If the item is not found, add a new item to the list with the given key/value
HashTableDictionary.cs (77) : //          - If the item is found, just update its value
HashTableDictionary.cs (79) : }
HashTableDictionary.cs (81) : public void Remove(TKey key)
HashTableDictionary.cs (82) : {
HashTableDictionary.cs (83) : //TODO #6: Using Position, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (84) : //         - If the item is not found, do nothing
HashTableDictionary.cs (85) : //         - If the item is found, remove it from the list and return
HashTableDictionary.cs (87) : }
HashTableDictionary.cs (89) : public TKey[] Keys()
HashTableDictionary.cs (90) : {
HashTableDictionary.cs (91) : //TODO #8: Return all the keys (not necessarily ordered) in an array
HashTableDictionary.cs (92) : //         If there is no element, it should return an empty array (size=0)
HashTableDictionary.cs (94) : return null;
HashTableDictionary.cs (96) : }
HashTableDictionary.cs (98) : public TValue[] Values()
HashTableDictionary.cs (99) : {
HashTableDictionary.cs (100) : //TODO #9: Return all the values (in the same order as the keys) in an array
HashTableDictionary.cs (101) : //         If there is no element, it should return an empty array (size=0)
HashTableDictionary.cs (103) : return null;
HashTableDictionary.cs (105) : }
HashTableDictionary.cs (106) : }
HashTableDictionaryItem.cs (1) : public class HashTableDictionaryItem<TKey, TValue>
HashTableDictionaryItem.cs (2) : {
HashTableDictionaryItem.cs (3) : public TKey Key;
HashTableDictionaryItem.cs (4) : public TValue Value;
HashTableDictionaryItem.cs (6) : public HashTableDictionaryItem(TKey key, TValue value)
HashTableDictionaryItem.cs (7) : {
HashTableDictionaryItem.cs (8) : Key = key;
HashTableDictionaryItem.cs (9) : Value = value;
HashTableDictionaryItem.cs (10) : }
HashTableDictionaryItem.cs (12) : public override string ToString()
HashTableDictionaryItem.cs (13) : {
HashTableDictionaryItem.cs (14) : if (!Key.Equals(default(TKey)))
HashTableDictionaryItem.cs (15) : return $"[{Key}->{Value}]\n";
HashTableDictionaryItem.cs (16) : else
HashTableDictionaryItem.cs (17) : return null;
HashTableDictionaryItem.cs (18) : }
HashTableDictionaryItem.cs (19) : }
main.cs (1) : using Common;
main.cs (2) : using System;
main.cs (3) : using System.Diagnostics;
main.cs (5) : class MainClass
main.cs (6) : {
main.cs (7) : public static void Main(string[] args)
main.cs (8) : {
main.cs (9) : Console.WriteLine("Testing HashTableDictionary<int,string>:\n");
main.cs (10) : bool success = Common.Tests.Test1_AddGetCount(new HashTableDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (11) : if (!success)
main.cs (12) : return;
main.cs (14) : success = Common.Tests.Test2_AddDuplicate(new HashTableDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (15) : if (!success)
main.cs (16) : return;
main.cs (18) : success = Common.Tests.Test3_Remove(new HashTableDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (19) : if (!success)
main.cs (20) : return;
main.cs (22) : success = Common.Tests.Test4_RemoveNonExistent(new HashTableDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (23) : if (!success)
main.cs (24) : return;
main.cs (26) : success = Common.Tests.Test5_KeysValues(new HashTableDictionary<int, string>(), Console.WriteLine, Console.WriteLine);
main.cs (27) : if (!success)
main.cs (28) : return;
main.cs (30) : success = Common.Tests.TestPerformanceWithTimeout(new HashTableDictionary<int, int>(), Console.WriteLine, Console.WriteLine);
main.cs (31) : if (!success)
main.cs (32) : return;
main.cs (34) : HashTableDictionary<string, int> numbers = new HashTableDictionary<string, int>();
main.cs (35) : success = Common.Tests.TestReaderWriterStringInt(numbers, "numbers-dictionary-hash-map.txt", Console.WriteLine, Console.WriteLine);
main.cs (36) : if (!success)
main.cs (37) : return;
main.cs (39) : HashTableDictionary<int, double> grades = new HashTableDictionary<int, double>();
main.cs (40) : success = Common.Tests.TestReaderWriterIntDouble(grades, "grades-dictionary-hash-map.txt", Console.WriteLine, Console.WriteLine);
main.cs (41) : if (!success)
main.cs (42) : return;
main.cs (44) : Console.WriteLine($"All tests passed.");
main.cs (45) : }
main.cs (46) : }
