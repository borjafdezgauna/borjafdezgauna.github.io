DirectedGraph.cs (2) : using System.Formats.Asn1;
GraphReaderWriter.cs (2) : using System.ComponentModel;
GraphReaderWriter.cs (4) : using System.Security.Cryptography;
GraphReaderWriter.cs (13) : if (string.IsNullOrEmpty(str) || string.IsNullOrWhiteSpace(str))
GraphReaderWriter.cs (14) : {
GraphReaderWriter.cs (16) : }
GraphReaderWriter.cs (17) : string output = str;
GraphReaderWriter.cs (18) : output = output.Replace(Environment.NewLine, "[NEW_LINE]");
GraphReaderWriter.cs (19) : output = output.Replace("->", "[FLECHA]");
GraphReaderWriter.cs (20) : output = output.Replace(".", "[COMA]");
GraphReaderWriter.cs (21) : return output;
GraphReaderWriter.cs (26) : if (string.IsNullOrEmpty(str) || string.IsNullOrWhiteSpace(str))
GraphReaderWriter.cs (27) : {
GraphReaderWriter.cs (29) : }
GraphReaderWriter.cs (30) : //TODO #24: Replace your special tags (i.e, "NEW_LINE") by the original separator before encoding it
GraphReaderWriter.cs (31) : string output = str;
GraphReaderWriter.cs (32) : output = output.Replace("[NEW_LINE]", Environment.NewLine);
GraphReaderWriter.cs (33) : output = output.Replace("[FLECHA]", "->");
GraphReaderWriter.cs (34) : output = output.Replace("[COMA]", ".");
GraphReaderWriter.cs (35) : return output;
GraphReaderWriter.cs (40) : return default;
GraphReaderWriter.cs (41) : /*           try
GraphReaderWriter.cs (45) : int lim = graph.EdgeCount();
GraphReaderWriter.cs (46) : string output = null;
GraphReaderWriter.cs (47) : TKey[] llaves = graph.GetVertex();
GraphReaderWriter.cs (48) : graph.VertexCount();
GraphReaderWriter.cs (49) : for (int i = 0; i < lim; i++)
GraphReaderWriter.cs (50) : {
GraphReaderWriter.cs (51) : output = EncodeString(keyToString(graph.GetVertex(llaves[i])));
GraphReaderWriter.cs (52) : }
GraphReaderWriter.cs (53) : var vertices = graph.GetVertex;
GraphReaderWriter.cs (54) : foreach (var vertex in vertices)
GraphReaderWriter.cs (55) : {
GraphReaderWriter.cs (57) : }
GraphReaderWriter.cs (66) : */
UnDirectedGraph.cs (78) : return totalEdges; // Cada arista se cuenta dos veces en un grafo no dirigido
UnDirectedGraph.cs (95) : return default(TWeight);
Vertex.cs (2) : using System.Collections.Generic;
Vertex.cs (3) : using System.ComponentModel;
Vertex.cs (4) : using System.Linq;
Vertex.cs (5) : using System.Linq.Expressions;
Vertex.cs (9) : private Dictionary<TElement, TWeight> edges;
Vertex.cs (16) : Element = element;
Vertex.cs (17) : edges = new Dictionary<TElement, TWeight>();
Vertex.cs (24) : return edges.Keys.ToArray();
Vertex.cs (30) : edges.Add(targetElement, weight);
Vertex.cs (37) : return edges.Count;
Vertex.cs (44) : edges.Remove(targetElement);
Vertex.cs (50) : if (edges.TryGetValue(targetElement, out TWeight weight))
Vertex.cs (51) : {
Vertex.cs (52) : return weight;
Vertex.cs (53) : }
Vertex.cs (54) : return default;
Vertex.cs (67) : foreach (var edge in edges)
Vertex.cs (68) : {
Vertex.cs (69) : output += $"{Element}->{edge.Value}->{edge.Key}";
Vertex.cs (70) : }
