BinaryGraphReaderWriter.cs (16) : /*               string output = null;
BinaryGraphReaderWriter.cs (28) : output += graph.VertexCount().ToString();
BinaryGraphReaderWriter.cs (30) : foreach (var vertex in Vertices.Values)
BinaryGraphReaderWriter.cs (31) : {
BinaryGraphReaderWriter.cs (32) : output += keyToByteArray(vertex.Keys()).ToString();
BinaryGraphReaderWriter.cs (33) : }
BinaryGraphReaderWriter.cs (34) : output += graph.EdgeCount().ToString();
BinaryGraphReaderWriter.cs (35) : foreach (var vertex in graph.Vertices.Values)
BinaryGraphReaderWriter.cs (36) : {
BinaryGraphReaderWriter.cs (37) : output += keyToByteArray(vertex.Keys()).ToString();
BinaryGraphReaderWriter.cs (38) : }
BinaryGraphReaderWriter.cs (40) : */
BinaryGraphReaderWriter.cs (43) : catch (Exception)
BinaryGraphReaderWriter.cs (69) : catch (Exception)
DirectedGraph.cs (2) : using System.Formats.Asn1;
DirectedGraph.cs (3) : using Microsoft.VisualBasic.FileIO;
DirectedGraph.cs (11) : foreach (var vertex in Vertices.Values)
DirectedGraph.cs (12) : {
DirectedGraph.cs (13) : if (vertex.Element.CompareTo(sourceKey) == 0)
DirectedGraph.cs (14) : {
DirectedGraph.cs (15) : vertex.AddEdge(destinationKey, weight);
DirectedGraph.cs (16) : }
DirectedGraph.cs (17) : }
DirectedGraph.cs (24) : if (Vertices.ContainsKey(element))
DirectedGraph.cs (25) : {
DirectedGraph.cs (26) : // Primero, eliminamos todas las aristas que apuntan a este vértice
DirectedGraph.cs (27) : foreach (var vertex in Vertices.Values)
DirectedGraph.cs (28) : {
DirectedGraph.cs (29) : vertex.RemoveEdge(element);
DirectedGraph.cs (30) : }
DirectedGraph.cs (31) : // Luego, eliminamos el vértice del grafo
DirectedGraph.cs (32) : Vertices.Remove(element);
DirectedGraph.cs (33) : }
DirectedGraph.cs (40) : foreach (var vertex in Vertices.Values)
DirectedGraph.cs (41) : {
DirectedGraph.cs (42) : if (vertex.Element.CompareTo(sourceKey) == 0)
DirectedGraph.cs (43) : {
DirectedGraph.cs (44) : vertex.RemoveEdge(destKey);
DirectedGraph.cs (45) : }
DirectedGraph.cs (46) : if (vertex.Element.CompareTo(destKey) == 0)
DirectedGraph.cs (47) : {
DirectedGraph.cs (48) : vertex.RemoveEdge(sourceKey);
DirectedGraph.cs (49) : }
DirectedGraph.cs (50) : }
DistanceCalculator.cs (8) : private UndirectedGraph<string,double>graph;
DistanceCalculator.cs (13) : if (isUndirected)
DistanceCalculator.cs (14) : {
DistanceCalculator.cs (15) : graph = new UndirectedGraph<string, double>();
DistanceCalculator.cs (16) : }
DistanceCalculator.cs (17) : else
DistanceCalculator.cs (18) : {
DistanceCalculator.cs (19) : graph = new DirectedGraph<string,double>();
DistanceCalculator.cs (20) : }
DistanceCalculator.cs (26) : graph.AddVertex(city);
DistanceCalculator.cs (32) : graph.AddEdge(fromCity,toCity,distance);
GraphReaderWriter.cs (2) : using System.ComponentModel;
GraphReaderWriter.cs (3) : using System.Globalization;
GraphReaderWriter.cs (5) : using System.Net;
GraphReaderWriter.cs (6) : using System.Security.Cryptography;
GraphReaderWriter.cs (15) : if (string.IsNullOrEmpty(str) || string.IsNullOrWhiteSpace(str))
GraphReaderWriter.cs (16) : {
GraphReaderWriter.cs (18) : }
GraphReaderWriter.cs (19) : string output = str;
GraphReaderWriter.cs (20) : output = output.Replace(Environment.NewLine, "[NEW_LINE]");
GraphReaderWriter.cs (21) : output = output.Replace("->", "[FLECHA]");
GraphReaderWriter.cs (22) : output = output.Replace(".", "[COMA]");
GraphReaderWriter.cs (23) : return output;
GraphReaderWriter.cs (28) : if (string.IsNullOrEmpty(str) || string.IsNullOrWhiteSpace(str))
GraphReaderWriter.cs (29) : {
GraphReaderWriter.cs (31) : }
GraphReaderWriter.cs (32) : //TODO #24: Replace your special tags (i.e, "NEW_LINE") by the original separator before encoding it
GraphReaderWriter.cs (33) : string output = str;
GraphReaderWriter.cs (34) : output = output.Replace("[NEW_LINE]", Environment.NewLine);
GraphReaderWriter.cs (35) : output = output.Replace("[FLECHA]", "->");
GraphReaderWriter.cs (36) : output = output.Replace("[COMA]", ".");
GraphReaderWriter.cs (37) : return output;
GraphReaderWriter.cs (42) : try
GraphReaderWriter.cs (47) : graph.ToString();
GraphReaderWriter.cs (49) : writer.WriteLine();
GraphReaderWriter.cs (51) : foreach (var element in graph.Elements())
GraphReaderWriter.cs (52) : {
GraphReaderWriter.cs (53) : writer.WriteLine(graph.GetVertex(element).ToString());
GraphReaderWriter.cs (54) : }
GraphReaderWriter.cs (61) : catch (Exception)
GraphReaderWriter.cs (70) : //TODO #26: Read all the vertices first and, when you find an empty line, start reading edges
GraphReaderWriter.cs (71) : //Edges will have the format "A->1->B", so you need to use line.Split("->") to receive the three different parts in an array
GraphReaderWriter.cs (75) : string linea = reader.ToString();
GraphReaderWriter.cs (76) : bool leyendoEdges = false;
GraphReaderWriter.cs (77) : while ((linea = reader.ReadLine()) != null)
GraphReaderWriter.cs (78) : {
GraphReaderWriter.cs (79) : if (string.IsNullOrEmpty(linea))
GraphReaderWriter.cs (80) : {
GraphReaderWriter.cs (81) : leyendoEdges = true;
GraphReaderWriter.cs (82) : continue;
GraphReaderWriter.cs (83) : }
GraphReaderWriter.cs (84) : if (!leyendoEdges)
GraphReaderWriter.cs (85) : {
GraphReaderWriter.cs (86) : TKey Vertex = stringToKey(linea);
GraphReaderWriter.cs (87) : graph.AddVertex(Vertex);
GraphReaderWriter.cs (88) : }
GraphReaderWriter.cs (89) : if (leyendoEdges)
GraphReaderWriter.cs (90) : {
GraphReaderWriter.cs (91) : string[] partes = linea.Split("->");
GraphReaderWriter.cs (93) : TKey source = stringToKey(partes[0]);
GraphReaderWriter.cs (94) : TWeight weight = stringToWeight(partes[1]);
GraphReaderWriter.cs (95) : TKey destination = stringToKey(partes[2]);
GraphReaderWriter.cs (97) : graph.AddEdge(source, destination, weight);
GraphReaderWriter.cs (98) : }
GraphReaderWriter.cs (100) : }
GraphReaderWriter.cs (105) : catch (Exception)
UnDirectedGraph.cs (78) : return totalEdges; // Cada arista se cuenta dos veces en un grafo no dirigido
UnDirectedGraph.cs (86) : {
UnDirectedGraph.cs (87) : if (vertex.EdgeCount() != 0)
UnDirectedGraph.cs (98) : }
UnDirectedGraph.cs (99) : return default(TWeight);
Vertex.cs (2) : using System.Collections.Generic;
Vertex.cs (3) : using System.ComponentModel;
Vertex.cs (4) : using System.Linq;
Vertex.cs (5) : using System.Linq.Expressions;
Vertex.cs (9) : private Dictionary<TElement, TWeight> edges;
Vertex.cs (16) : Element = element;
Vertex.cs (17) : edges = new Dictionary<TElement, TWeight>();
Vertex.cs (24) : return edges.Keys.ToArray();
Vertex.cs (30) : if (!edges.TryAdd(targetElement, weight))
Vertex.cs (31) : {
Vertex.cs (32) : edges.Remove(targetElement);
Vertex.cs (33) : edges.Add(targetElement, weight);
Vertex.cs (36) : }
Vertex.cs (42) : return edges.Count;
Vertex.cs (49) : edges.Remove(targetElement);
Vertex.cs (55) : if (edges.TryGetValue(targetElement, out TWeight weight))
Vertex.cs (56) : {
Vertex.cs (57) : return weight;
Vertex.cs (58) : }
Vertex.cs (59) : return default;
Vertex.cs (72) : foreach (var edge in edges)
Vertex.cs (73) : {
Vertex.cs (74) : output += $"{Element}->{edge.Value}->{edge.Key}";
Vertex.cs (75) : }
