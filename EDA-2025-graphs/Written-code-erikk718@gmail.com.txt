BinaryGraphReaderWriter.cs (44) : int vertexCount = reader.ReadInt32();
BinaryGraphReaderWriter.cs (46) : for(int i = 0; i < vertexCount; i++)
BinaryGraphReaderWriter.cs (47) : {
BinaryGraphReaderWriter.cs (48) : int keyLength = reader.ReadInt32();
BinaryGraphReaderWriter.cs (49) : byte[] keyBytes = reader.ReadBytes(keyLength);
BinaryGraphReaderWriter.cs (50) : TKey key = keyFromByteArray(keyBytes);
BinaryGraphReaderWriter.cs (51) : graph.AddVertex(key);
BinaryGraphReaderWriter.cs (52) : }
BinaryGraphReaderWriter.cs (53) : int edgeCount = reader.ReadInt32();
BinaryGraphReaderWriter.cs (55) : for(int i = 0;i < edgeCount; i++)
BinaryGraphReaderWriter.cs (56) : {
BinaryGraphReaderWriter.cs (57) : int sourceLength = reader.ReadInt32();
BinaryGraphReaderWriter.cs (58) : byte[] sourceBytes = reader.ReadBytes(sourceLength);
BinaryGraphReaderWriter.cs (59) : TKey sourceKey = keyFromByteArray(sourceBytes);
BinaryGraphReaderWriter.cs (61) : int weightLength = reader.ReadInt32();
BinaryGraphReaderWriter.cs (62) : byte[] weightBytes = reader.ReadBytes(weightLength);
BinaryGraphReaderWriter.cs (63) : TWeight weight = weightFromByteArray(weightBytes);
BinaryGraphReaderWriter.cs (65) : int destLength = reader.ReadInt32();
BinaryGraphReaderWriter.cs (66) : byte[] destBytes = reader.ReadBytes(destLength);
BinaryGraphReaderWriter.cs (67) : TKey destKey = keyFromByteArray(destBytes);
BinaryGraphReaderWriter.cs (69) : graph.AddEdge(sourceKey,destKey,weight);
BinaryGraphReaderWriter.cs (70) : }
UnDirectedGraph.cs (2) : using System.Collections.Generic;
UnDirectedGraph.cs (3) : using System.Net.Http.Headers;
UnDirectedGraph.cs (12) : protected Dictionary<TElement, Vertex<TElement, TWeight>> Vertices;
UnDirectedGraph.cs (14) : public UndirectedGraph()
UnDirectedGraph.cs (15) : {
UnDirectedGraph.cs (16) : Vertices = new Dictionary<TElement, Vertex<TElement, TWeight>>();
UnDirectedGraph.cs (17) : }
UnDirectedGraph.cs (25) : if (Vertices != null)
UnDirectedGraph.cs (27) : foreach (Vertex<TElement, TWeight> vertex in Vertices.Values) // Sin par√©ntesis y sin crear array
UnDirectedGraph.cs (29) : output += vertex.ToString() + "\n";
UnDirectedGraph.cs (43) : TElement[] elementsArray = new TElement[Vertices.Count];
UnDirectedGraph.cs (44) : int i = 0;
UnDirectedGraph.cs (45) : foreach (TElement key in Vertices.Keys)
UnDirectedGraph.cs (46) : {
UnDirectedGraph.cs (47) : elementsArray[i] = key;
UnDirectedGraph.cs (49) : return elementsArray;
UnDirectedGraph.cs (50) : }
UnDirectedGraph.cs (51) : return new TElement[0];
UnDirectedGraph.cs (65) : Vertices[source].AddEdge(destination, weight);
UnDirectedGraph.cs (66) : Vertices[destination].AddEdge(source, weight);
UnDirectedGraph.cs (75) : return Vertices.Count;
UnDirectedGraph.cs (83) : int edgeCount = 0;
UnDirectedGraph.cs (86) : foreach (var vertex in Vertices.Values)
UnDirectedGraph.cs (88) : edgeCount += vertex.EdgeCount();
UnDirectedGraph.cs (91) : return edgeCount / 2;
UnDirectedGraph.cs (98) : if (Vertices != null && Vertices.ContainsKey(source))
UnDirectedGraph.cs (100) : return Vertices[source].GetEdgeWeight(destination);
UnDirectedGraph.cs (102) : return default(TWeight);
UnDirectedGraph.cs (111) : if (Vertices.ContainsKey(source))
UnDirectedGraph.cs (112) : {
UnDirectedGraph.cs (113) : Vertices[source].RemoveEdge(destination);
UnDirectedGraph.cs (114) : }
UnDirectedGraph.cs (115) : if (Vertices.ContainsKey(destination))
UnDirectedGraph.cs (117) : Vertices[destination].RemoveEdge(source);
UnDirectedGraph.cs (125) : if (Vertices != null && Vertices.ContainsKey(element))
UnDirectedGraph.cs (128) : foreach (var vertex in Vertices.Values)
UnDirectedGraph.cs (130) : vertex.RemoveEdge(element);
UnDirectedGraph.cs (139) : if (Vertices != null && Vertices.ContainsKey(element))
UnDirectedGraph.cs (140) : {
UnDirectedGraph.cs (141) : return Vertices[element];
UnDirectedGraph.cs (142) : }
UnDirectedGraph.cs (143) : return null;
Vertex.cs (2) : using System.Collections.Generic;
Vertex.cs (3) : using System.Text;
Vertex.cs (8) : public List<TElement> targets;
Vertex.cs (9) : public List<TWeight> weights;
Vertex.cs (14) : this.Element = element;
Vertex.cs (15) : this.targets = new List<TElement>();
Vertex.cs (16) : this.weights = new List<TWeight>();
Vertex.cs (23) : return targets.ToArray();
Vertex.cs (30) : for (int i = 0; i < targets.Count; i++)
Vertex.cs (31) : {
Vertex.cs (32) : if (targets[i].CompareTo(targetElement) == 0)
Vertex.cs (33) : {
Vertex.cs (34) : weights[i] = weight;
Vertex.cs (35) : return;
Vertex.cs (36) : }
Vertex.cs (37) : }
Vertex.cs (39) : targets.Add(targetElement);
Vertex.cs (40) : weights.Add(weight);
Vertex.cs (47) : return targets.Count;
Vertex.cs (54) : for (int i = 0; i < targets.Count; i++)
Vertex.cs (55) : {
Vertex.cs (56) : if (targets[i].CompareTo(targetElement) == 0)
Vertex.cs (57) : {
Vertex.cs (59) : targets.RemoveAt(i);
Vertex.cs (60) : weights.RemoveAt(i);
Vertex.cs (61) : return;
Vertex.cs (62) : }
Vertex.cs (63) : }
Vertex.cs (69) : for (int i = 0; i < targets.Count; i++)
Vertex.cs (70) : {
Vertex.cs (71) : if (targets[i].CompareTo(targetElement) == 0)
Vertex.cs (72) : {
Vertex.cs (73) : return weights[i];
Vertex.cs (74) : }
Vertex.cs (75) : }
Vertex.cs (88) : string output = "";
Vertex.cs (89) : for(int i = 0;i < targets.Count; i++)
Vertex.cs (90) : {
Vertex.cs (91) : output += this.Element + "->" + weights[i] + "->" + targets[i] + "\n";
Vertex.cs (92) : }
