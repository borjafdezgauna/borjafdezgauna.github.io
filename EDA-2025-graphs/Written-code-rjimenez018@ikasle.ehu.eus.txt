DirectedGraph.cs (9) : Vertices.Get(sourceKey).AddEdge(destinationKey, weight);
DirectedGraph.cs (13) : //TODO #21: Remove the vertex that contains this element
DirectedGraph.cs (14) : //and any edge that starts from or ends on that vertex
DirectedGraph.cs (16) : Vertices.Remove(element);
DirectedGraph.cs (17) : foreach (TElement key in Vertices.Keys())
DirectedGraph.cs (19) : RemoveEdge(key,element);
DirectedGraph.cs (25) : Vertices.Get(sourceKey).RemoveEdge(destKey);
DistanceCalculator.cs (38) : //TODO #33: Choose the candidate with the minimum distance from nextCityCandidates
DistanceCalculator.cs (39) : //that hasn't been visited yet
DistanceCalculator.cs (64) : //TODO #34: Add to nextCityCandidates all the neighbours of the currentCity,
DistanceCalculator.cs (65) : //updating their distances in distanceToCity too
DistanceCalculator.cs (91) : //Calculate the distance to each city in the graph from fromCity.The result is a binary tree
DistanceCalculator.cs (92) : //where the key is the city and the value the distance
DistanceCalculator.cs (97) : IDictionary<string, double> distanceToCity = new HashTableDictionary<string, double>();
DistanceCalculator.cs (98) : IDictionary<string, bool> visited = new HashTableDictionary<string,bool>();
DistanceCalculator.cs (99) : IDictionary<string, double> nextCityCandidates = new HashTableDictionary<string, double>();
DistanceCalculator.cs (101) : foreach (var node in graph.Elements())
DistanceCalculator.cs (102) : {
DistanceCalculator.cs (103) : distanceToCity.Add(node, double.MaxValue);
DistanceCalculator.cs (104) : visited.Add(node,false);
DistanceCalculator.cs (105) : }
DistanceCalculator.cs (107) : distanceToCity.Add(fromCity,0);
DistanceCalculator.cs (108) : nextCityCandidates.Add(fromCity,0);
DistanceCalculator.cs (109) : string currentCity = fromCity;
DistanceCalculator.cs (110) : currentCity = fromCity;
DistanceCalculator.cs (112) : while (currentCity != null)
DistanceCalculator.cs (113) : {
DistanceCalculator.cs (114) : CheckNeighbours(distanceToCity,visited,nextCityCandidates,currentCity);
DistanceCalculator.cs (115) : visited.Remove(currentCity);
DistanceCalculator.cs (116) : visited.Add(currentCity, true);
DistanceCalculator.cs (117) : currentCity = ChooseNextUnvisitedCity(visited,nextCityCandidates);
DistanceCalculator.cs (119) : if (currentCity != null)
DistanceCalculator.cs (120) : {
DistanceCalculator.cs (121) : nextCityCandidates.Remove(currentCity);
DistanceCalculator.cs (122) : }
DistanceCalculator.cs (123) : }
DistanceCalculator.cs (124) : return distanceToCity;
GraphReaderWriter.cs (11) : return str.Replace("\n", "[NEW_LINE]");
GraphReaderWriter.cs (16) : return str.Replace("[NEW_LINE]", "\n");
GraphReaderWriter.cs (28) : //TODO #25: Write first all the vertices as strings (one line each),
GraphReaderWriter.cs (29) : //then one empty line, and then each of the edges with the format "A->1->B" (one line each)
GraphReaderWriter.cs (38) : foreach (TKey source in graph.Elements())
GraphReaderWriter.cs (40) : foreach (TKey destination in graph.GetVertex(source).aristas.Keys())
GraphReaderWriter.cs (42) : if(!source.Equals(destination))
GraphReaderWriter.cs (43) : {
GraphReaderWriter.cs (44) : TWeight weight = graph.GetEdgeWeight(source,destination);
GraphReaderWriter.cs (45) : String output = keyToString(source) + "->" + weightToString(weight) + "->" + keyToString(destination);
GraphReaderWriter.cs (46) : writer.WriteLine(EncodeString(output));
GraphReaderWriter.cs (47) : }
GraphReaderWriter.cs (67) : //TODO #26: Read all the vertices first and, when you find an empty line, start reading edges
GraphReaderWriter.cs (68) : //Edges will have the format "A->1->B", so you need to use line.Split("->") to receive
GraphReaderWriter.cs (69) : //the three different parts in an array
GraphReaderWriter.cs (70) : string line;
GraphReaderWriter.cs (72) : while ((line = reader.ReadLine()) != "")
GraphReaderWriter.cs (74) : graph.AddVertex(stringToKey(DecodeString(line)));
GraphReaderWriter.cs (77) : reader.ReadLine();
GraphReaderWriter.cs (79) : while ((line = reader.ReadLine()) != null)
GraphReaderWriter.cs (81) : line = DecodeString(line);
GraphReaderWriter.cs (82) : String[] datos = line.Split("->");
GraphReaderWriter.cs (83) : graph.AddVertex(stringToKey(datos[0]));
GraphReaderWriter.cs (84) : graph.AddEdge(stringToKey(datos[0]),stringToKey(datos[2]),stringToWeight(datos[1]));
List.cs (45) : int count = 0;
List.cs (46) : ListNode<T> current = First;
List.cs (47) : while (current != null)
List.cs (48) : {
List.cs (49) : count++;
List.cs (50) : current = current.Next;
List.cs (51) : }
List.cs (52) : return count;
UnDirectedGraph.cs (10) : protected HashTableDictionary<TElement, Vertex<TElement, TWeight>> Vertices = new HashTableDictionary<TElement, Vertex<TElement, TWeight>>();
UnDirectedGraph.cs (16) : foreach ( TElement Vertice in Vertices.Keys() )
UnDirectedGraph.cs (18) : output += Vertices.Get(Vertice).ToString() + "\n";
UnDirectedGraph.cs (27) : TElement[] resultado = new TElement[Vertices.Count()];
UnDirectedGraph.cs (28) : foreach( TElement Vertice in Vertices.Keys() )
UnDirectedGraph.cs (30) : resultado[contador] = Vertice;
UnDirectedGraph.cs (39) : Vertices.Add(element, new Vertex<TElement, TWeight>(element));
UnDirectedGraph.cs (45) : Vertices.Get(source).AddEdge(destination,weight);
UnDirectedGraph.cs (46) : Vertices.Get(destination).AddEdge(source,weight);
UnDirectedGraph.cs (53) : return Vertices.Count();
UnDirectedGraph.cs (58) : //TODO #15: Return the number of edges.
UnDirectedGraph.cs (59) : //Edges are stored in each vertex, so vertices need to be traversed to count edges
UnDirectedGraph.cs (60) : int contador = 0;
UnDirectedGraph.cs (61) : foreach(Vertex<TElement, TWeight> Vertice in Vertices.Values())
UnDirectedGraph.cs (62) : {
UnDirectedGraph.cs (63) : contador = contador + Vertice.EdgeCount();
UnDirectedGraph.cs (64) : }
UnDirectedGraph.cs (65) : return contador;
UnDirectedGraph.cs (70) : //TODO #16: Return the number of edges.
UnDirectedGraph.cs (71) : //Edges are stored in each vertex, so vertices need to be traversed to count edges
UnDirectedGraph.cs (72) : return Vertices.Get(source).GetEdgeWeight(destination);
UnDirectedGraph.cs (79) : if (Vertices.Get(source) != null)
UnDirectedGraph.cs (80) : {
UnDirectedGraph.cs (81) : Vertices.Get(source).RemoveEdge(destination);
UnDirectedGraph.cs (82) : }
UnDirectedGraph.cs (83) : else if (Vertices.Get(destination) != null)
UnDirectedGraph.cs (84) : {
UnDirectedGraph.cs (85) : Vertices.Get(destination).RemoveEdge(source);
UnDirectedGraph.cs (86) : }
UnDirectedGraph.cs (91) : //TODO #18: Remove the vertex that contains element and
UnDirectedGraph.cs (92) : //any edge that starts from or ends on that vertex
UnDirectedGraph.cs (93) : Vertices.Remove(element);
UnDirectedGraph.cs (94) : foreach (TElement key in Vertices.Keys())
UnDirectedGraph.cs (95) : {
UnDirectedGraph.cs (96) : RemoveEdge(key,element);
UnDirectedGraph.cs (97) : }
UnDirectedGraph.cs (103) : return Vertices.Get(element);
