DirectedGraph.cs (11) : if (sourceKey==null || destinationKey==null || weight==null)
DirectedGraph.cs (12) : {
DirectedGraph.cs (13) : return;
DirectedGraph.cs (14) : }
DirectedGraph.cs (16) : Vertex<TElement, TWeight> origen = Vertices.Get(sourceKey);
DirectedGraph.cs (18) : if (origen == null)
DirectedGraph.cs (19) : {
DirectedGraph.cs (20) : return;
DirectedGraph.cs (21) : }
DirectedGraph.cs (23) : origen.AddEdge(destinationKey, weight);
DirectedGraph.cs (31) : if (element == null)
DirectedGraph.cs (32) : {
DirectedGraph.cs (33) : return;
DirectedGraph.cs (34) : }
DirectedGraph.cs (36) : TElement[] claves = Vertices.Keys();
DirectedGraph.cs (37) : for (int i = 0; i < claves.Length; i++)
DirectedGraph.cs (38) : {
DirectedGraph.cs (39) : Vertex<TElement, TWeight> vertice = Vertices.Get(claves[i]);
DirectedGraph.cs (40) : vertice.RemoveEdge(element);
DirectedGraph.cs (41) : }
DirectedGraph.cs (42) : Vertices.Remove(element);
DirectedGraph.cs (51) : Vertex<TElement, TWeight> origen = Vertices.Get(sourceKey);
DirectedGraph.cs (52) : origen.RemoveEdge(destKey);
DistanceCalculator.cs (38) : private void CheckNeighbour(IDictionary<string, double> distanceToCity, IDictionary<string, bool> visited,
UnDirectedGraph.cs (21) : TWeight weight = Vertices.Get(elemento).GetEdgeWeight(elemento);
Vertex.cs (3) : using System.Collections.Generic;
Vertex.cs (4) : using Common;
Vertex.cs (9) : //TODO #1: Store edges starting from this vertex. Each edge has a weight and we want to
Vertex.cs (10) : // be able to quickly find the edge to any other vertex
Vertex.cs (20) : this.Element= element;
Vertex.cs (21) : aristas = new Dictionary<TElement, TWeight>();
Vertex.cs (29) : TElement[] conectados = new TElement[aristas.Count];
Vertex.cs (30) : aristas.Keys.CopyTo(conectados, 0);
Vertex.cs (31) : return conectados;
Vertex.cs (38) : aristas[targetElement] = weight;
Vertex.cs (44) : return aristas.Count;
Vertex.cs (51) : if (targetElement == null)
Vertex.cs (52) : {
Vertex.cs (53) : return;
Vertex.cs (54) : }
Vertex.cs (56) : aristas.Remove(targetElement);
Vertex.cs (63) : if (targetElement == null || !aristas.ContainsKey(targetElement) )
Vertex.cs (64) : {
Vertex.cs (65) : return default(TWeight);
Vertex.cs (66) : }
Vertex.cs (68) : return aristas[targetElement];
Vertex.cs (80) : string resultado = "";
Vertex.cs (81) : TElement[] elementosConectados = ConnectedElements();
Vertex.cs (83) : for (int i = 0; i < elementosConectados.Length; i++)
Vertex.cs (85) : TElement segundoElemento = elementosConectados[i];
Vertex.cs (86) : TWeight peso = aristas[segundoElemento];
Vertex.cs (88) : resultado += Element + "->" + peso + "->" + segundoElemento;
Vertex.cs (90) : if (i < elementosConectados.Length - 1)
Vertex.cs (91) : resultado += "\n";
Vertex.cs (94) : return resultado;
