DirectedGraph.cs (11) : if (sourceKey==null || destinationKey==null || weight==null)
DirectedGraph.cs (12) : {
DirectedGraph.cs (13) : return;
DirectedGraph.cs (14) : }
DirectedGraph.cs (16) : Vertex<TElement, TWeight> origen = Vertices.Get(sourceKey);
DirectedGraph.cs (18) : if (origen == null)
DirectedGraph.cs (19) : {
DirectedGraph.cs (20) : return;
DirectedGraph.cs (21) : }
DirectedGraph.cs (23) : origen.AddEdge(destinationKey, weight);
DirectedGraph.cs (31) : if (element == null)
DirectedGraph.cs (32) : {
DirectedGraph.cs (33) : return;
DirectedGraph.cs (34) : }
DirectedGraph.cs (36) : TElement[] claves = Vertices.Keys();
DirectedGraph.cs (37) : for (int i = 0; i < claves.Length; i++)
DirectedGraph.cs (38) : {
DirectedGraph.cs (39) : Vertex<TElement, TWeight> vertice = Vertices.Get(claves[i]);
DirectedGraph.cs (40) : vertice.RemoveEdge(element);
DirectedGraph.cs (41) : }
DirectedGraph.cs (42) : Vertices.Remove(element);
DirectedGraph.cs (51) : Vertex<TElement, TWeight> origen = Vertices.Get(sourceKey);
DirectedGraph.cs (52) : origen.RemoveEdge(destKey);
DistanceCalculator.cs (38) : private void CheckNeighbour(IDictionary<string, double> distanceToCity, IDictionary<string, bool> visited,
Vertex.cs (3) : using System.Collections.Generic;
Vertex.cs (4) : using Common;
Vertex.cs (9) : //TODO #1: Store edges starting from this vertex. Each edge has a weight and we want to
Vertex.cs (10) : // be able to quickly find the edge to any other vertex
Vertex.cs (25) : return conectados;
Vertex.cs (44) : aristas.Remove(targetElement);
Vertex.cs (64) : string resultado = "";
Vertex.cs (67) : for (int i = 0; i < elementosConectados.Length; i++)
Vertex.cs (69) : TElement segundoElemento = elementosConectados[i];
Vertex.cs (72) : resultado += Element + "->" + peso + "->" + segundoElemento;
Vertex.cs (75) : return resultado;
