BinaryGraphReaderWriter.cs (4) : using System.Collections.Generic; // Necesario para usar List<>
BinaryGraphReaderWriter.cs (21) : TKey[] vertices = graph.Elements();
BinaryGraphReaderWriter.cs (22) : writer.Write(vertices.Length);
BinaryGraphReaderWriter.cs (25) : foreach (TKey vertexKey in vertices)
BinaryGraphReaderWriter.cs (26) : {
BinaryGraphReaderWriter.cs (27) : byte[] keyBytes = keyToByteArray(vertexKey);
BinaryGraphReaderWriter.cs (28) : // Note: before write an array of bytes... write the number of bytes
BinaryGraphReaderWriter.cs (29) : writer.Write(keyBytes.Length);
BinaryGraphReaderWriter.cs (30) : writer.Write(keyBytes);
BinaryGraphReaderWriter.cs (31) : }
BinaryGraphReaderWriter.cs (34) : var allEdges = new List<Tuple<TKey, TKey, TWeight>>();
BinaryGraphReaderWriter.cs (35) : foreach (TKey source in vertices)
BinaryGraphReaderWriter.cs (36) : {
BinaryGraphReaderWriter.cs (37) : var vertexObj = graph.GetVertex(source);
BinaryGraphReaderWriter.cs (38) : foreach (TKey dest in vertexObj.ConnectedElements())
BinaryGraphReaderWriter.cs (39) : {
BinaryGraphReaderWriter.cs (40) : TWeight weight = graph.GetEdgeWeight(source, dest);
BinaryGraphReaderWriter.cs (41) : allEdges.Add(new Tuple<TKey, TKey, TWeight>(source, dest, weight));
BinaryGraphReaderWriter.cs (42) : }
BinaryGraphReaderWriter.cs (43) : }
BinaryGraphReaderWriter.cs (45) : writer.Write(allEdges.Count);
BinaryGraphReaderWriter.cs (48) : foreach (var edge in allEdges)
BinaryGraphReaderWriter.cs (49) : {
BinaryGraphReaderWriter.cs (51) : byte[] sourceBytes = keyToByteArray(edge.Item1);
BinaryGraphReaderWriter.cs (52) : writer.Write(sourceBytes.Length);
BinaryGraphReaderWriter.cs (53) : writer.Write(sourceBytes);
BinaryGraphReaderWriter.cs (56) : byte[] weightBytes = weightToByteArray(edge.Item3);
BinaryGraphReaderWriter.cs (57) : writer.Write(weightBytes.Length);
BinaryGraphReaderWriter.cs (58) : writer.Write(weightBytes);
BinaryGraphReaderWriter.cs (60) : //  -The key of the destination
BinaryGraphReaderWriter.cs (61) : byte[] destBytes = keyToByteArray(edge.Item2);
BinaryGraphReaderWriter.cs (62) : writer.Write(destBytes.Length);
BinaryGraphReaderWriter.cs (63) : writer.Write(destBytes);
BinaryGraphReaderWriter.cs (64) : }
BinaryGraphReaderWriter.cs (86) : int vertexCount = reader.ReadInt32();
BinaryGraphReaderWriter.cs (89) : for (int i = 0; i < vertexCount; i++)
BinaryGraphReaderWriter.cs (90) : {
BinaryGraphReaderWriter.cs (91) : // Leemos longitud -> leemos bytes -> convertimos
BinaryGraphReaderWriter.cs (92) : int length = reader.ReadInt32();
BinaryGraphReaderWriter.cs (93) : byte[] bytes = reader.ReadBytes(length);
BinaryGraphReaderWriter.cs (94) : TKey key = keyFromByteArray(bytes);
BinaryGraphReaderWriter.cs (96) : graph.AddVertex(key);
BinaryGraphReaderWriter.cs (97) : }
BinaryGraphReaderWriter.cs (100) : int edgeCount = reader.ReadInt32();
BinaryGraphReaderWriter.cs (103) : for (int i = 0; i < edgeCount; i++)
BinaryGraphReaderWriter.cs (104) : {
BinaryGraphReaderWriter.cs (106) : int sLen = reader.ReadInt32();
BinaryGraphReaderWriter.cs (107) : byte[] sBytes = reader.ReadBytes(sLen);
BinaryGraphReaderWriter.cs (108) : TKey source = keyFromByteArray(sBytes);
BinaryGraphReaderWriter.cs (111) : int wLen = reader.ReadInt32();
BinaryGraphReaderWriter.cs (112) : byte[] wBytes = reader.ReadBytes(wLen);
BinaryGraphReaderWriter.cs (113) : TWeight weight = weightFromByteArray(wBytes);
BinaryGraphReaderWriter.cs (116) : int dLen = reader.ReadInt32();
BinaryGraphReaderWriter.cs (117) : byte[] dBytes = reader.ReadBytes(dLen);
BinaryGraphReaderWriter.cs (118) : TKey destination = keyFromByteArray(dBytes);
BinaryGraphReaderWriter.cs (119) : graph.AddEdge(source, destination, weight);
BinaryGraphReaderWriter.cs (120) : }
DirectedGraph.cs (2) : using System.Collections.Generic;
DirectedGraph.cs (9) : if (this.Vertices.ContainsKey(sourceKey) && this.Vertices.ContainsKey(destinationKey))
DirectedGraph.cs (10) : {
DirectedGraph.cs (11) : this.Vertices[sourceKey].AddEdge(destinationKey, weight);
DirectedGraph.cs (12) : }
DirectedGraph.cs (18) : if (this.Vertices.ContainsKey(element))
DirectedGraph.cs (19) : {
DirectedGraph.cs (20) : foreach (var vertex in this.Vertices.Values)
DirectedGraph.cs (21) : {
DirectedGraph.cs (22) : try
DirectedGraph.cs (23) : {
DirectedGraph.cs (24) : vertex.RemoveEdge(element);
DirectedGraph.cs (25) : }
DirectedGraph.cs (26) : catch
DirectedGraph.cs (27) : {
DirectedGraph.cs (30) : }
DirectedGraph.cs (31) : this.Vertices.Remove(element);
DirectedGraph.cs (32) : }
DirectedGraph.cs (33) : }
DirectedGraph.cs (38) : if (this.Vertices.ContainsKey(sourceKey) && this.Vertices.ContainsKey(destKey))
DirectedGraph.cs (39) : {
DirectedGraph.cs (40) : this.Vertices[sourceKey].RemoveEdge(destKey);
DirectedGraph.cs (41) : }
DistanceCalculator.cs (2) : using System.Collections.Generic;
DistanceCalculator.cs (4) : using Common;
DistanceCalculator.cs (6) : public class AdapterDictionary<TKey, TValue> : Common.IDictionary<TKey, TValue>
DistanceCalculator.cs (8) : private Dictionary<TKey, TValue> _dictionary;
DistanceCalculator.cs (10) : public AdapterDictionary()
DistanceCalculator.cs (12) : _dictionary = new Dictionary<TKey, TValue>();
DistanceCalculator.cs (15) : public void Add(TKey key, TValue value)
DistanceCalculator.cs (17) : if (_dictionary.ContainsKey(key))
DistanceCalculator.cs (18) : _dictionary[key] = value;
DistanceCalculator.cs (19) : else
DistanceCalculator.cs (20) : _dictionary.Add(key, value);
DistanceCalculator.cs (25) : return _dictionary.Count;
DistanceCalculator.cs (30) : if (!_dictionary.ContainsKey(key))
DistanceCalculator.cs (31) : return default(TValue);
DistanceCalculator.cs (32) : return _dictionary[key];
DistanceCalculator.cs (37) : return _dictionary.Keys.ToArray();
DistanceCalculator.cs (40) : public void Remove(TKey key)
DistanceCalculator.cs (42) : _dictionary.Remove(key);
DistanceCalculator.cs (45) : public TValue[] Values()
DistanceCalculator.cs (47) : return _dictionary.Values.ToArray();
DistanceCalculator.cs (51) : public class DistanceCalculator
DistanceCalculator.cs (53) : //TODO #29: Declare a graph as a member-variable/attribute. We will store here the names of the cities and the distances between them
DistanceCalculator.cs (54) : private UndirectedGraph<string, double> graph;
DistanceCalculator.cs (56) : public DistanceCalculator(bool isUndirected)
DistanceCalculator.cs (58) : //TODO #30: Initialize the graph used to store the cities/distances. If isUndirected, use an undirected graph. Otherwise, a directed
DistanceCalculator.cs (59) : if (isUndirected)
DistanceCalculator.cs (61) : this.graph = new UndirectedGraph<string, double>();
DistanceCalculator.cs (63) : else
DistanceCalculator.cs (65) : this.graph = new DirectedGraph<string, double>();
DistanceCalculator.cs (69) : public void AddCity(string city)
DistanceCalculator.cs (71) : //TODO #31: Add to the graph a vertex with the name of this city. This method will be called several times before calling CalculateDistances()
DistanceCalculator.cs (72) : this.graph.AddVertex(city);
DistanceCalculator.cs (75) : public void AddDistance(string fromCity, string toCity, double distance)
DistanceCalculator.cs (77) : //TODO #32: Set the distance between these two cities in the graph. These cities should already be in the graph. This method will be called several times before calling CalculateDistances()
DistanceCalculator.cs (78) : this.graph.AddEdge(fromCity, toCity, distance);
DistanceCalculator.cs (81) : private string ChooseNextUnvisitedCity(Common.IDictionary<string, bool> visited, Common.IDictionary<string, double> nextCityCandidates)
DistanceCalculator.cs (83) : //TODO #33: Choose the candidate with the minimum distance from nextCityCandidates that hasn't been visited yet
DistanceCalculator.cs (84) : //We will use this method in CalculateDistances()
DistanceCalculator.cs (86) : string closestCity = null;
DistanceCalculator.cs (87) : double minDistance = double.MaxValue;
DistanceCalculator.cs (89) : string[] candidates = nextCityCandidates.Keys();
DistanceCalculator.cs (90) : foreach (var city in candidates)
DistanceCalculator.cs (92) : bool isVisited = false;
DistanceCalculator.cs (93) : if (visited.Get(city) == true)
DistanceCalculator.cs (95) : isVisited = true;
DistanceCalculator.cs (98) : if (!isVisited)
DistanceCalculator.cs (100) : double dist = nextCityCandidates.Get(city);
DistanceCalculator.cs (101) : if (dist < minDistance)
DistanceCalculator.cs (103) : minDistance = dist;
DistanceCalculator.cs (104) : closestCity = city;
DistanceCalculator.cs (108) : return closestCity;
DistanceCalculator.cs (111) : private void CheckNeighbour(Common.IDictionary<string, double> distanceToCity, Common.IDictionary<string, bool> visited,
DistanceCalculator.cs (112) : Common.IDictionary<string, double> nextCityCandidates, string currentCity)
DistanceCalculator.cs (114) : //TODO #34: Add to nextCityCandidates all the neighbours of the currentCity, updating their distances in distanceToCity too
DistanceCalculator.cs (115) : //We will use this method in CalculateDistances()
DistanceCalculator.cs (117) : var vertex = this.graph.GetVertex(currentCity);
DistanceCalculator.cs (118) : string[] neighbors = vertex.ConnectedElements();
DistanceCalculator.cs (119) : double currentDist = distanceToCity.Get(currentCity);
DistanceCalculator.cs (121) : foreach (string neighbor in neighbors)
DistanceCalculator.cs (123) : if (visited.Get(neighbor))
DistanceCalculator.cs (124) : continue;
DistanceCalculator.cs (126) : double weight = vertex.GetEdgeWeight(neighbor);
DistanceCalculator.cs (127) : double newDist = currentDist + weight;
DistanceCalculator.cs (129) : double oldDist = distanceToCity.Get(neighbor);
DistanceCalculator.cs (131) : // Si no existe (0 es el default de nuestro adapter si no existe, pero ojo si la distancia real es 0.
DistanceCalculator.cs (132) : // Mejor lógica: si es double.MaxValue o si no está en keys)
DistanceCalculator.cs (133) : // Asumimos que distanceToCity se inicializa con MaxValue o comprobamos claves.
DistanceCalculator.cs (134) : // En nuestra lógica de CalculateDistances inicializamos todo.
DistanceCalculator.cs (136) : if (newDist < oldDist)
DistanceCalculator.cs (138) : distanceToCity.Add(neighbor, newDist);
DistanceCalculator.cs (139) : nextCityCandidates.Add(neighbor, newDist);
DistanceCalculator.cs (144) : public Common.IDictionary<string, double> CalculateDistances(string fromCity)
DistanceCalculator.cs (146) : //TODO #34: Add one of the two dictionary classes to this project before implementing this method
DistanceCalculator.cs (147) : //Calculate the distance to each city in the graph from fromCity.The result is a binary tree where the key is the city and the value the distance
DistanceCalculator.cs (148) : //          a) Initialize variables: distanceToCity<string,double>, visited<string,bool> and nextCityCandidates<string,double>, currentCity
DistanceCalculator.cs (149) : //          b) While currentyCity != null
DistanceCalculator.cs (150) : //          b.1)    Find candidates for next step calculating (updating nextCityCandidates) -> USE CheckNeighbours()
DistanceCalculator.cs (151) : //          b.2)    Select the next city (the one with the min distance in nextCityCandidates) and update currentCity -> USE ChooseNextUnvisitedCity()
DistanceCalculator.cs (153) : var distanceToCity = new AdapterDictionary<string, double>();
DistanceCalculator.cs (154) : var visited = new AdapterDictionary<string, bool>();
DistanceCalculator.cs (155) : var nextCityCandidates = new AdapterDictionary<string, double>();
DistanceCalculator.cs (157) : string[] allCities = this.graph.Elements();
DistanceCalculator.cs (158) : foreach (var city in allCities)
DistanceCalculator.cs (160) : if (city == fromCity)
DistanceCalculator.cs (162) : distanceToCity.Add(city, 0);
DistanceCalculator.cs (163) : nextCityCandidates.Add(city, 0);
DistanceCalculator.cs (165) : else
DistanceCalculator.cs (167) : distanceToCity.Add(city, double.MaxValue);
DistanceCalculator.cs (169) : visited.Add(city, false);
DistanceCalculator.cs (172) : string currentCity = fromCity;
DistanceCalculator.cs (174) : while (currentCity != null)
DistanceCalculator.cs (176) : visited.Add(currentCity, true);
DistanceCalculator.cs (177) : nextCityCandidates.Remove(currentCity);
DistanceCalculator.cs (179) : CheckNeighbour(distanceToCity, visited, nextCityCandidates, currentCity);
DistanceCalculator.cs (181) : currentCity = ChooseNextUnvisitedCity(visited, nextCityCandidates);
DistanceCalculator.cs (184) : return distanceToCity;
GraphReaderWriter.cs (3) : using System.Collections.Generic;
GraphReaderWriter.cs (13) : if (str == null) return "null";
GraphReaderWriter.cs (14) : return str.Replace("\n", "[NEW_LINE]").Replace("->", "[ARROW]");
GraphReaderWriter.cs (20) : if (str == null) return null;
GraphReaderWriter.cs (21) : return str.Replace("[NEW_LINE]", "\n").Replace("[ARROW]", "->");
GraphReaderWriter.cs (30) : using (TextWriter writer = File.CreateText(filename))
GraphReaderWriter.cs (31) : {
GraphReaderWriter.cs (34) : foreach (TKey key in graph.Elements())
GraphReaderWriter.cs (35) : {
GraphReaderWriter.cs (36) : writer.WriteLine(EncodeString(keyToString(key)));
GraphReaderWriter.cs (37) : }
GraphReaderWriter.cs (39) : writer.WriteLine();
GraphReaderWriter.cs (40) : foreach (TKey source in graph.Elements())
GraphReaderWriter.cs (41) : {
GraphReaderWriter.cs (42) : var vertex = graph.GetVertex(source);
GraphReaderWriter.cs (43) : foreach (TKey destination in vertex.ConnectedElements())
GraphReaderWriter.cs (44) : {
GraphReaderWriter.cs (45) : TWeight weight = graph.GetEdgeWeight(source, destination);
GraphReaderWriter.cs (47) : string sourceStr = EncodeString(keyToString(source));
GraphReaderWriter.cs (48) : string weightStr = EncodeString(weightToString(weight));
GraphReaderWriter.cs (49) : string destStr = EncodeString(keyToString(destination));
GraphReaderWriter.cs (50) : writer.WriteLine($"{sourceStr}->{weightStr}->{destStr}");
GraphReaderWriter.cs (51) : }
GraphReaderWriter.cs (52) : }
GraphReaderWriter.cs (53) : }
GraphReaderWriter.cs (67) : using (TextReader reader = File.OpenText(filename))
GraphReaderWriter.cs (68) : {
GraphReaderWriter.cs (72) : string line;
GraphReaderWriter.cs (73) : bool readingEdges = false;
GraphReaderWriter.cs (75) : while ((line = reader.ReadLine()) != null)
GraphReaderWriter.cs (76) : {
GraphReaderWriter.cs (77) : if (string.IsNullOrEmpty(line))
GraphReaderWriter.cs (78) : {
GraphReaderWriter.cs (79) : readingEdges = true;
GraphReaderWriter.cs (80) : continue;
GraphReaderWriter.cs (81) : }
GraphReaderWriter.cs (83) : if (!readingEdges)
GraphReaderWriter.cs (84) : {
GraphReaderWriter.cs (85) : TKey key = stringToKey(DecodeString(line));
GraphReaderWriter.cs (86) : graph.AddVertex(key);
GraphReaderWriter.cs (87) : }
GraphReaderWriter.cs (88) : else
GraphReaderWriter.cs (89) : {
GraphReaderWriter.cs (90) : string[] parts = line.Split(new string[] { "->" }, StringSplitOptions.None);
GraphReaderWriter.cs (92) : if (parts.Length == 3)
GraphReaderWriter.cs (93) : {
GraphReaderWriter.cs (94) : TKey source = stringToKey(DecodeString(parts[0]));
GraphReaderWriter.cs (95) : TWeight weight = stringToWeight(DecodeString(parts[1]));
GraphReaderWriter.cs (96) : TKey destination = stringToKey(DecodeString(parts[2]));
GraphReaderWriter.cs (98) : graph.AddEdge(source, destination, weight);
GraphReaderWriter.cs (99) : }
GraphReaderWriter.cs (100) : }
GraphReaderWriter.cs (101) : }
GraphReaderWriter.cs (102) : }
UnDirectedGraph.cs (2) : using System.Collections.Generic;
UnDirectedGraph.cs (3) : using System.Diagnostics.Contracts;
UnDirectedGraph.cs (4) : using System.Linq;
UnDirectedGraph.cs (5) : using System.Text;
UnDirectedGraph.cs (7) : // SIN NAMESPACE PARA EVITAR ERRORES DE COMPILACIÓN EN LOS TESTS
UnDirectedGraph.cs (10) : //TODO #9: Declare a PROTECTED member variable/attribute called Vertices.
UnDirectedGraph.cs (11) : protected Dictionary<TElement, Vertex<TElement, TWeight>> Vertices = new Dictionary<TElement, Vertex<TElement, TWeight>>();
UnDirectedGraph.cs (16) : StringBuilder result = new StringBuilder();
UnDirectedGraph.cs (17) : foreach (var vertex in this.Vertices.Values)
UnDirectedGraph.cs (18) : {
UnDirectedGraph.cs (19) : result.AppendLine(vertex.ToString());
UnDirectedGraph.cs (20) : }
UnDirectedGraph.cs (21) : return result.ToString();
UnDirectedGraph.cs (27) : return this.Vertices.Keys.ToArray();
UnDirectedGraph.cs (33) : if (!this.Vertices.ContainsKey(element))
UnDirectedGraph.cs (34) : {
UnDirectedGraph.cs (35) : this.Vertices.Add(element, new Vertex<TElement, TWeight>(element));
UnDirectedGraph.cs (36) : }
UnDirectedGraph.cs (42) : if (this.Vertices.ContainsKey(source) && this.Vertices.ContainsKey(destination))
UnDirectedGraph.cs (43) : {
UnDirectedGraph.cs (45) : this.Vertices[source].AddEdge(destination, weight);
UnDirectedGraph.cs (46) : this.Vertices[destination].AddEdge(source, weight);
UnDirectedGraph.cs (47) : }
UnDirectedGraph.cs (53) : return this.Vertices.Count;
UnDirectedGraph.cs (58) : //TODO #15: Return the number of edges.
UnDirectedGraph.cs (59) : int count = 0;
UnDirectedGraph.cs (60) : foreach (var vertex in this.Vertices.Values)
UnDirectedGraph.cs (61) : {
UnDirectedGraph.cs (62) : count += vertex.EdgeCount();
UnDirectedGraph.cs (63) : }
UnDirectedGraph.cs (64) : return count;
UnDirectedGraph.cs (69) : // TODO #16: Return the weight of the edge...
UnDirectedGraph.cs (70) : if (!this.Vertices.ContainsKey(source))
UnDirectedGraph.cs (71) : {
UnDirectedGraph.cs (72) : return default(TWeight);
UnDirectedGraph.cs (73) : }
UnDirectedGraph.cs (75) : return this.Vertices[source].GetEdgeWeight(destination);
UnDirectedGraph.cs (81) : if (this.Vertices.ContainsKey(source) && this.Vertices.ContainsKey(destination))
UnDirectedGraph.cs (82) : {
UnDirectedGraph.cs (83) : this.Vertices[source].RemoveEdge(destination);
UnDirectedGraph.cs (84) : this.Vertices[destination].RemoveEdge(source);
UnDirectedGraph.cs (85) : }
UnDirectedGraph.cs (91) : if (this.Vertices.ContainsKey(element))
UnDirectedGraph.cs (92) : {
UnDirectedGraph.cs (93) : Vertex<TElement, TWeight> vertexToRemove = this.Vertices[element];
UnDirectedGraph.cs (94) : TElement[] neighbors = vertexToRemove.ConnectedElements();
UnDirectedGraph.cs (96) : foreach (TElement neighbor in neighbors)
UnDirectedGraph.cs (97) : {
UnDirectedGraph.cs (98) : if (this.Vertices.ContainsKey(neighbor))
UnDirectedGraph.cs (99) : {
UnDirectedGraph.cs (100) : this.Vertices[neighbor].RemoveEdge(element);
UnDirectedGraph.cs (101) : }
UnDirectedGraph.cs (102) : }
UnDirectedGraph.cs (103) : this.Vertices.Remove(element);
UnDirectedGraph.cs (104) : }
UnDirectedGraph.cs (110) : if (this.Vertices.ContainsKey(element))
UnDirectedGraph.cs (111) : {
UnDirectedGraph.cs (112) : return this.Vertices[element];
UnDirectedGraph.cs (113) : }
UnDirectedGraph.cs (114) : throw new KeyNotFoundException($"Vertex {element} not found.");
Vertex.cs (2) : using System.Collections.Generic;
Vertex.cs (3) : using System.Linq;
Vertex.cs (4) : using System.Text;
Vertex.cs (10) : private Dictionary<TElement, TWeight> edges;
Vertex.cs (15) : this.Element = element;
Vertex.cs (16) : this.edges = new Dictionary<TElement, TWeight>();
Vertex.cs (22) : return this.edges.Keys.ToArray();
Vertex.cs (28) : if (this.edges.ContainsKey(targetElement))
Vertex.cs (29) : {
Vertex.cs (30) : this.edges[targetElement] = weight;
Vertex.cs (32) : else
Vertex.cs (33) : {
Vertex.cs (34) : this.edges.Add(targetElement, weight);
Vertex.cs (35) : }
Vertex.cs (36) : }
Vertex.cs (41) : return this.edges.Count;
Vertex.cs (47) : this.edges.Remove(targetElement);
Vertex.cs (52) : // TODO #7: Return the weight of the edge...
Vertex.cs (53) : if (this.edges.ContainsKey(targetElement))
Vertex.cs (54) : {
Vertex.cs (55) : return this.edges[targetElement];
Vertex.cs (57) : return default(TWeight);
Vertex.cs (58) : }
Vertex.cs (62) : //TODO #8: Represent the edges in this vertex with the following format.
Vertex.cs (63) : StringBuilder sb = new StringBuilder();
Vertex.cs (64) : foreach (KeyValuePair<TElement, TWeight> item in this.edges)
Vertex.cs (65) : {
Vertex.cs (66) : sb.AppendLine($"{this.Element}->{item.Value}->{item.Key}");
Vertex.cs (67) : }
Vertex.cs (68) : return sb.ToString();
