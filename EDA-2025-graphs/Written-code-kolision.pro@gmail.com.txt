UnDirectedGraph.cs (2) : using System.Linq.Expressions;
UnDirectedGraph.cs (3) : using System.Threading;
UnDirectedGraph.cs (4) : using Common;
UnDirectedGraph.cs (13) : protected IDictionary<TElement, Vertex<TElement, TWeight>> vertices;
UnDirectedGraph.cs (19) : string output = "";
UnDirectedGraph.cs (20) : Vertex<TElement, TWeight>[] vertexes = vertices.Values();
UnDirectedGraph.cs (22) : for (int i = 0; i < vertices.Count(); i++)
UnDirectedGraph.cs (23) : {
UnDirectedGraph.cs (24) : output += vertexes[i].ToString() + "\n";
UnDirectedGraph.cs (25) : }
UnDirectedGraph.cs (34) : return vertices.Keys();
UnDirectedGraph.cs (42) : if (vertices.Get(element) == null)
UnDirectedGraph.cs (43) : {
UnDirectedGraph.cs (44) : //vertices.Add(element, Vertex<element, >);
UnDirectedGraph.cs (45) : }
UnDirectedGraph.cs (51) : if (vertices.Get(source) == null)
UnDirectedGraph.cs (52) : {
UnDirectedGraph.cs (53) : AddVertex(source);
UnDirectedGraph.cs (54) : }
UnDirectedGraph.cs (55) : if (vertices.Get(destination) == null)
UnDirectedGraph.cs (56) : {
UnDirectedGraph.cs (57) : AddVertex(destination);
UnDirectedGraph.cs (58) : }
UnDirectedGraph.cs (60) : vertices.Get(source).AddEdge(destination, weight);
UnDirectedGraph.cs (62) : vertices.Get(destination).AddEdge(source, weight);
UnDirectedGraph.cs (69) : return vertices.Count();
UnDirectedGraph.cs (77) : int total = 0;
UnDirectedGraph.cs (78) : for (int i = 0; i < vertices.Count(); i++)
UnDirectedGraph.cs (79) : {
UnDirectedGraph.cs (80) : total += vertices.Values()[i].EdgeCount();
UnDirectedGraph.cs (81) : }
UnDirectedGraph.cs (82) : return total;
Vertex.cs (2) : using System.Security.Cryptography;
Vertex.cs (3) : using Common;
Vertex.cs (9) : public IDictionary<TElement, TWeight> edges;
Vertex.cs (14) : this.Element = element;
Vertex.cs (21) : if (edges == null)
Vertex.cs (22) : {
Vertex.cs (23) : return new TElement[0];
Vertex.cs (24) : }
Vertex.cs (25) : else
Vertex.cs (26) : {
Vertex.cs (27) : return edges.Keys();
Vertex.cs (28) : }
Vertex.cs (34) : this.edges.Add(targetElement, weight);
Vertex.cs (41) : return this.edges.Count();
Vertex.cs (48) : this.edges.Remove(targetElement);
Vertex.cs (56) : return this.edges.Get(targetElement);
Vertex.cs (68) : string output = "";
Vertex.cs (69) : TElement[] elements = edges.Keys();
Vertex.cs (70) : TWeight[] weights = edges.Values();
Vertex.cs (71) : for (int i = 0; i < EdgeCount(); i++)
Vertex.cs (72) : {
Vertex.cs (73) : output = Element + "->" + weights[i] + "->" + elements[i];
Vertex.cs (74) : }
