BinaryGraphReaderWriter.cs (28) : bool isDirected = graph is DirectedGraph<TKey, TWeight>; //Comprobamos si el grafo es dirigido o no
BinaryGraphReaderWriter.cs (30) : //Escribir el número de vértices
BinaryGraphReaderWriter.cs (31) : TKey[] vertices = graph.Elements();//Devuelve todas las claves de los vértices del grafo
BinaryGraphReaderWriter.cs (32) : writer.Write(vertices.Length);//Guardamos el número de vértices
BinaryGraphReaderWriter.cs (34) : //Escribir las claves de los vértices
BinaryGraphReaderWriter.cs (35) : for (int i = 0; i < vertices.Length; i++)
BinaryGraphReaderWriter.cs (36) : {
BinaryGraphReaderWriter.cs (37) : byte[] keyBytes = keyToByteArray(vertices[i]); //Convertimos la clave del vértice a un array de bytes
BinaryGraphReaderWriter.cs (38) : writer.Write(keyBytes.Length); //Escribimos el número de bytes que tiene la clave
BinaryGraphReaderWriter.cs (39) : writer.Write(keyBytes); //Escribimos la clave del vértice
BinaryGraphReaderWriter.cs (40) : }
BinaryGraphReaderWriter.cs (42) : //Escribir el número de aristas (Solo una vez cada arista en un grafo no dirigido)
BinaryGraphReaderWriter.cs (43) : int edgeCount = 0;
BinaryGraphReaderWriter.cs (44) : for (int i = 0; i < vertices.Length; i++)
BinaryGraphReaderWriter.cs (45) : {
BinaryGraphReaderWriter.cs (46) : Vertex<TKey, TWeight> v = graph.GetVertex(vertices[i]);
BinaryGraphReaderWriter.cs (47) : TKey[] connected = v.ConnectedElements();
BinaryGraphReaderWriter.cs (49) : for (int j = 0; j < v.ConnectedElements().Length; j++)
BinaryGraphReaderWriter.cs (50) : {
BinaryGraphReaderWriter.cs (51) : //solo contamos la arista si la clave del vértice origen es menor que la del destino, para no duplicarlas
BinaryGraphReaderWriter.cs (52) : if (isDirected || vertices[i].CompareTo(v.ConnectedElements()[j]) < 0)
BinaryGraphReaderWriter.cs (53) : {
BinaryGraphReaderWriter.cs (54) : edgeCount++;
BinaryGraphReaderWriter.cs (55) : }
BinaryGraphReaderWriter.cs (56) : }
BinaryGraphReaderWriter.cs (57) : }
BinaryGraphReaderWriter.cs (58) : writer.Write(edgeCount);
BinaryGraphReaderWriter.cs (60) : //Escribir las aristas
BinaryGraphReaderWriter.cs (61) : for (int i = 0; i < vertices.Length; i++)
BinaryGraphReaderWriter.cs (62) : {
BinaryGraphReaderWriter.cs (63) : Vertex<TKey, TWeight> v = graph.GetVertex(vertices[i]);
BinaryGraphReaderWriter.cs (64) : TKey[] connected = v.ConnectedElements();
BinaryGraphReaderWriter.cs (66) : for (int j = 0; j < connected.Length; j++)
BinaryGraphReaderWriter.cs (67) : {
BinaryGraphReaderWriter.cs (68) : //Para evitar escribir dos veces la misma arista en un grafo no dirigido
BinaryGraphReaderWriter.cs (69) : if (isDirected || vertices[i].CompareTo(connected[j]) < 0)
BinaryGraphReaderWriter.cs (70) : {
BinaryGraphReaderWriter.cs (71) : //Obtener el peso de la arista
BinaryGraphReaderWriter.cs (72) : TWeight weight = v.GetEdgeWeight(connected[j]);
BinaryGraphReaderWriter.cs (74) : //Escribir la clave del vértice origen
BinaryGraphReaderWriter.cs (75) : byte[] sourceKeyBytes = keyToByteArray(vertices[i]);
BinaryGraphReaderWriter.cs (76) : writer.Write(sourceKeyBytes.Length);
BinaryGraphReaderWriter.cs (77) : writer.Write(sourceKeyBytes);
BinaryGraphReaderWriter.cs (79) : //Escribir el peso de la arista
BinaryGraphReaderWriter.cs (80) : byte[] weightBytes = weightToByteArray(weight);
BinaryGraphReaderWriter.cs (81) : writer.Write(weightBytes.Length);
BinaryGraphReaderWriter.cs (82) : writer.Write(weightBytes);
BinaryGraphReaderWriter.cs (84) : //Escribir la clave del vértice destino
BinaryGraphReaderWriter.cs (85) : byte[] destKeyBytes = keyToByteArray(connected[j]);
BinaryGraphReaderWriter.cs (86) : writer.Write(destKeyBytes.Length);
BinaryGraphReaderWriter.cs (87) : writer.Write(destKeyBytes);
BinaryGraphReaderWriter.cs (88) : }
BinaryGraphReaderWriter.cs (89) : }
BinaryGraphReaderWriter.cs (90) : }
BinaryGraphReaderWriter.cs (119) : //Leer el número de vértices
BinaryGraphReaderWriter.cs (120) : int vertexCount = reader.ReadInt32();
BinaryGraphReaderWriter.cs (122) : //Leer las claves de los vértices
BinaryGraphReaderWriter.cs (123) : for (int i = 0; i < vertexCount; i++)
BinaryGraphReaderWriter.cs (124) : {
BinaryGraphReaderWriter.cs (125) : int keyLength = reader.ReadInt32(); //Leemos el número de bytes que tiene la clave
BinaryGraphReaderWriter.cs (126) : byte[] keyBytes = reader.ReadBytes(keyLength); //Leemos los bytes de la clave
BinaryGraphReaderWriter.cs (127) : TKey key = keyFromByteArray(keyBytes); //Convertimos el array de bytes a la clave del vértice
BinaryGraphReaderWriter.cs (128) : graph.AddVertex(key); //Añadimos el vértice al grafo
BinaryGraphReaderWriter.cs (129) : }
BinaryGraphReaderWriter.cs (131) : //Leer el número de aristas
BinaryGraphReaderWriter.cs (132) : int edgeCount = reader.ReadInt32();
BinaryGraphReaderWriter.cs (134) : //Leer las aristas
BinaryGraphReaderWriter.cs (135) : for (int i = 0; i < edgeCount; i++)
BinaryGraphReaderWriter.cs (136) : {
BinaryGraphReaderWriter.cs (137) : //Leer la clave del vértice origen
BinaryGraphReaderWriter.cs (138) : int sourceKeyLength = reader.ReadInt32();
BinaryGraphReaderWriter.cs (139) : byte[] sourceKeyBytes = reader.ReadBytes(sourceKeyLength);
BinaryGraphReaderWriter.cs (140) : TKey sourceKey = keyFromByteArray(sourceKeyBytes);
BinaryGraphReaderWriter.cs (142) : //Leer el peso de la arista
BinaryGraphReaderWriter.cs (143) : int weightLength = reader.ReadInt32();
BinaryGraphReaderWriter.cs (144) : byte[] weightBytes = reader.ReadBytes(weightLength);
BinaryGraphReaderWriter.cs (145) : TWeight weight = weightFromByteArray(weightBytes);
BinaryGraphReaderWriter.cs (147) : //Leer la clave del vértice destino
BinaryGraphReaderWriter.cs (148) : int destKeyLength = reader.ReadInt32();
BinaryGraphReaderWriter.cs (149) : byte[] destKeyBytes = reader.ReadBytes(destKeyLength);
BinaryGraphReaderWriter.cs (150) : TKey destKey = keyFromByteArray(destKeyBytes);
BinaryGraphReaderWriter.cs (152) : //Añadir la arista al grafo
BinaryGraphReaderWriter.cs (153) : graph.AddEdge(sourceKey, destKey, weight);
BinaryGraphReaderWriter.cs (154) : }
DirectedGraph.cs (9) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(sourceKey);
DirectedGraph.cs (10) : sourceVertex.AddEdge(destinationKey, weight);
DirectedGraph.cs (18) : Vertex<TElement, TWeight> vertexToRemove = Vertices.Get(element);
DirectedGraph.cs (19) : //Eliminar todas las aristas que salen de este vértice a otros vértices
DirectedGraph.cs (20) : TElement[] connectedElements = vertexToRemove.ConnectedElements();
DirectedGraph.cs (21) : for (int i = 0; i < connectedElements.Length; i++)
DirectedGraph.cs (22) : {
DirectedGraph.cs (23) : vertexToRemove.RemoveEdge(connectedElements[i]);
DirectedGraph.cs (24) : }
DirectedGraph.cs (25) : //Eliminar las aristas que entran a este vértice desde otros vértices
DirectedGraph.cs (26) : Vertex<TElement, TWeight>[] enteringVertex = Vertices.Values();
DirectedGraph.cs (27) : for (int i = 0; i < enteringVertex.Length; i++)
DirectedGraph.cs (28) : {
DirectedGraph.cs (29) : enteringVertex[i].RemoveEdge(element);
DirectedGraph.cs (30) : }
DirectedGraph.cs (31) : //Finalmente, eliminar el vértice del grafo
DirectedGraph.cs (32) : Vertices.Remove(element);
DirectedGraph.cs (39) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(sourceKey);
DirectedGraph.cs (40) : sourceVertex.RemoveEdge(destKey);
DistanceCalculator.cs (2) : using System.Runtime.CompilerServices;
DistanceCalculator.cs (10) : private IDictionary<string, IDictionary<string, double>> graph;
DistanceCalculator.cs (12) : private bool isUndirected;
DistanceCalculator.cs (18) : this.isUndirected = isUndirected;
DistanceCalculator.cs (19) : graph = new HashTableDictionary<string, IDictionary<string, double>>();
DistanceCalculator.cs (28) : if (graph.Get(city) == null)
DistanceCalculator.cs (29) : {
DistanceCalculator.cs (30) : graph.Add(city, new HashTableDictionary<string, double>());
DistanceCalculator.cs (31) : }
DistanceCalculator.cs (39) : graph.Get(fromCity).Add(toCity, distance);
DistanceCalculator.cs (40) : if (isUndirected)
DistanceCalculator.cs (41) : {
DistanceCalculator.cs (42) : graph.Get(toCity).Add(fromCity, distance);
DistanceCalculator.cs (43) : }
DistanceCalculator.cs (52) : string nextCity = null;
DistanceCalculator.cs (53) : double minDistance = double.MaxValue;
DistanceCalculator.cs (54) : foreach (var candidate in nextCityCandidates.Keys())
DistanceCalculator.cs (55) : {
DistanceCalculator.cs (56) : if (!visited.Get(candidate) && nextCityCandidates.Get(candidate) < minDistance)
DistanceCalculator.cs (57) : {
DistanceCalculator.cs (58) : minDistance = nextCityCandidates.Get(candidate);;
DistanceCalculator.cs (59) : nextCity = candidate;
DistanceCalculator.cs (60) : }
DistanceCalculator.cs (61) : }
DistanceCalculator.cs (62) : return nextCity;
DistanceCalculator.cs (73) : IDictionary<string, double> neighbours = graph.Get(currentCity);
DistanceCalculator.cs (74) : double currentDistance = distanceToCity.Get(currentCity);
DistanceCalculator.cs (75) : foreach (var n in neighbours.Keys())
DistanceCalculator.cs (76) : {
DistanceCalculator.cs (77) : if (!visited.Get(n))
DistanceCalculator.cs (78) : {
DistanceCalculator.cs (79) : double newDistance = currentDistance + neighbours.Get(n);
DistanceCalculator.cs (80) : double oldDistance = distanceToCity.Get(n);
DistanceCalculator.cs (82) : if (newDistance < oldDistance)
DistanceCalculator.cs (83) : {
DistanceCalculator.cs (84) : distanceToCity.Add(n, newDistance);
DistanceCalculator.cs (85) : nextCityCandidates.Add(n, newDistance);
DistanceCalculator.cs (86) : }
DistanceCalculator.cs (87) : }
DistanceCalculator.cs (88) : }
DistanceCalculator.cs (101) : //Diccionario de ciudad que calcula la distancia a cada ciudad
DistanceCalculator.cs (102) : IDictionary<string, double> distanceToCity = new HashTableDictionary<string, double>();
DistanceCalculator.cs (103) : //Diccionario de ciudades visitadas
DistanceCalculator.cs (104) : IDictionary<string, bool> visited = new HashTableDictionary<string, bool>();
DistanceCalculator.cs (105) : //Diccionario de candidatos a la siguiente ciudad
DistanceCalculator.cs (106) : IDictionary<string, double> nextCityCandidates = new HashTableDictionary<string, double>();
DistanceCalculator.cs (108) : //Recorremos todas las ciudades del grafo para inicializar los diccionarios
DistanceCalculator.cs (109) : foreach (var city in graph.Keys())
DistanceCalculator.cs (110) : {
DistanceCalculator.cs (111) : //verificamos si es la ciudad de origen
DistanceCalculator.cs (112) : if (city == fromCity)
DistanceCalculator.cs (113) : {
DistanceCalculator.cs (114) : //distancia a si misma es 0
DistanceCalculator.cs (115) : distanceToCity.Add(city, 0);
DistanceCalculator.cs (116) : //agregamos la cicudad de origen como nuestro primer candidato a la siguiente ciudad
DistanceCalculator.cs (117) : nextCityCandidates.Add(city, 0);
DistanceCalculator.cs (118) : }
DistanceCalculator.cs (119) : else
DistanceCalculator.cs (120) : {
DistanceCalculator.cs (121) : //distancia inicial a las demas ciudades es infinito, porque aún no sabemos la distancia real
DistanceCalculator.cs (122) : distanceToCity.Add(city, double.MaxValue);
DistanceCalculator.cs (123) : }
DistanceCalculator.cs (124) : //inicialmente ninguna ciudad ha sido visitada
DistanceCalculator.cs (125) : visited.Add(city, false);
DistanceCalculator.cs (126) : }
DistanceCalculator.cs (127) : //empezamos desde la ciudad de origen
DistanceCalculator.cs (128) : string currentCity = fromCity;
DistanceCalculator.cs (130) : while (currentCity != null)
DistanceCalculator.cs (131) : {
DistanceCalculator.cs (132) : //Marcar la ciudad actual como visitada
DistanceCalculator.cs (133) : visited.Add(currentCity, true);
DistanceCalculator.cs (134) : //Eliminar la ciudad actual de los candidatos a la siguiente ciudad
DistanceCalculator.cs (135) : nextCityCandidates.Remove(currentCity);
DistanceCalculator.cs (136) : //Actualizar los candidatos a la siguiente ciudad
DistanceCalculator.cs (137) : CheckNeighbours(distanceToCity, visited, nextCityCandidates, currentCity);
DistanceCalculator.cs (138) : //Seleccionar la siguiente ciudad
DistanceCalculator.cs (139) : currentCity = ChooseNextUnvisitedCity(visited, nextCityCandidates);
DistanceCalculator.cs (140) : }
DistanceCalculator.cs (142) : return distanceToCity;
GraphReaderWriter.cs (11) : for (int i = 0; i < str.Length; i++)
GraphReaderWriter.cs (12) : {
GraphReaderWriter.cs (13) : if (str[i] == '\n')
GraphReaderWriter.cs (14) : {
GraphReaderWriter.cs (15) : str = str.Replace("\n", "[NEW_LINE]");
GraphReaderWriter.cs (16) : }
GraphReaderWriter.cs (17) : }
GraphReaderWriter.cs (25) : for (int i = 0; i < str.Length; i++)
GraphReaderWriter.cs (26) : {
GraphReaderWriter.cs (27) : if (str.Contains("[NEW_LINE]"))
GraphReaderWriter.cs (28) : {
GraphReaderWriter.cs (29) : str = str.Replace("[NEW_LINE]", "\n");
GraphReaderWriter.cs (30) : }
GraphReaderWriter.cs (31) : }
GraphReaderWriter.cs (44) : TKey[] vertices = graph.Elements();
GraphReaderWriter.cs (45) : for (int i = 0; i < vertices.Length; i++)
GraphReaderWriter.cs (46) : {
GraphReaderWriter.cs (47) : writer.WriteLine(EncodeString(keyToString(vertices[i])));
GraphReaderWriter.cs (48) : }
GraphReaderWriter.cs (49) : writer.WriteLine();
GraphReaderWriter.cs (50) : for (int i = 0; i < vertices.Length; i++)
GraphReaderWriter.cs (51) : {
GraphReaderWriter.cs (52) : Vertex<TKey, TWeight> v = graph.GetVertex(vertices[i]);
GraphReaderWriter.cs (53) : TKey[] connected = v.ConnectedElements();
GraphReaderWriter.cs (54) : for (int j = 0; j < connected.Length; j++)
GraphReaderWriter.cs (55) : {
GraphReaderWriter.cs (57) : TWeight weight = v.GetEdgeWeight(connected[j]);
GraphReaderWriter.cs (58) : writer.WriteLine(EncodeString(keyToString(vertices[i]) + "->" + weightToString(weight) + "->" + keyToString(connected[j])));
GraphReaderWriter.cs (59) : }
GraphReaderWriter.cs (60) : }
GraphReaderWriter.cs (81) : string line = reader.ReadLine();
GraphReaderWriter.cs (82) : while (line != null && line != "")
GraphReaderWriter.cs (83) : {
GraphReaderWriter.cs (84) : graph.AddVertex(stringToKey(DecodeString(line)));
GraphReaderWriter.cs (85) : line = reader.ReadLine();
GraphReaderWriter.cs (86) : }
GraphReaderWriter.cs (87) : line = reader.ReadLine();
GraphReaderWriter.cs (88) : while (line != null)
GraphReaderWriter.cs (89) : {
GraphReaderWriter.cs (90) : if (line != "")
GraphReaderWriter.cs (91) : {
GraphReaderWriter.cs (92) : string[] partes = DecodeString(line).Split(new string[] { "->" }, StringSplitOptions.None);
GraphReaderWriter.cs (93) : TKey keyA = stringToKey(partes[0]);
GraphReaderWriter.cs (94) : TWeight weight = stringToWeight(partes[1]);
GraphReaderWriter.cs (95) : TKey keyB = stringToKey(partes[2]);
GraphReaderWriter.cs (96) : graph.AddEdge(keyA, keyB, weight);
GraphReaderWriter.cs (97) : }
GraphReaderWriter.cs (98) : line = reader.ReadLine();
GraphReaderWriter.cs (99) : }
HashTableDictionary.cs (1) : using System;
HashTableDictionary.cs (2) : using System.Collections;
HashTableDictionary.cs (3) : using Common;
HashTableDictionary.cs (5) : public class HashTableDictionary<TKey, TValue> : IDictionary<TKey, TValue>
HashTableDictionary.cs (6) : {
HashTableDictionary.cs (7) : int DefaultNumEntries = 10000;
HashTableDictionary.cs (8) : int NumElements = 0;
HashTableDictionary.cs (9) : //TODO #1: Copy your implementation of List to the project HashTableDictionary and use it to declare Entries: an array of lists of HashTableDictionaryItem<TKey,TValue>
HashTableDictionary.cs (10) : //[USE List and HashTableDictionaryItem HERE] [] Entries;
HashTableDictionary.cs (11) : public class ListNode<T>
HashTableDictionary.cs (12) : {
HashTableDictionary.cs (13) : public T Value;
HashTableDictionary.cs (14) : public ListNode<T> Next = null;
HashTableDictionary.cs (15) : public ListNode<T> Previous = null;
HashTableDictionary.cs (18) : public ListNode(T value)
HashTableDictionary.cs (19) : {
HashTableDictionary.cs (20) : Value = value;
HashTableDictionary.cs (21) : }
HashTableDictionary.cs (23) : public override string ToString()
HashTableDictionary.cs (24) : {
HashTableDictionary.cs (25) : return Value.ToString();
HashTableDictionary.cs (26) : }
HashTableDictionary.cs (27) : }
HashTableDictionary.cs (29) : public class List<T>
HashTableDictionary.cs (30) : {
HashTableDictionary.cs (31) : ListNode<T> First = null;
HashTableDictionary.cs (32) : ListNode<T> Last = null;
HashTableDictionary.cs (34) : int m_numItems = 0;
HashTableDictionary.cs (36) : public override string ToString()
HashTableDictionary.cs (37) : {
HashTableDictionary.cs (38) : ListNode<T> node = First;
HashTableDictionary.cs (39) : string output = "[";
HashTableDictionary.cs (41) : while (node != null)
HashTableDictionary.cs (42) : {
HashTableDictionary.cs (43) : output += node.ToString() + ",";
HashTableDictionary.cs (44) : node = node.Next;
HashTableDictionary.cs (45) : }
HashTableDictionary.cs (46) : output = output.TrimEnd(',') + "] " + Count() + " elements";
HashTableDictionary.cs (48) : return output;
HashTableDictionary.cs (49) : }
HashTableDictionary.cs (51) : public int Count()
HashTableDictionary.cs (52) : {
HashTableDictionary.cs (53) : //TODO #1: return the number of elements on the list
HashTableDictionary.cs (55) : return m_numItems;
HashTableDictionary.cs (57) : }
HashTableDictionary.cs (59) : public T Get(int index)
HashTableDictionary.cs (60) : {
HashTableDictionary.cs (61) : //TODO #2: return the element on the index-th position. O if the position is out of bounds
HashTableDictionary.cs (63) : if(index < 0 || index >= Count())
HashTableDictionary.cs (64) : {
HashTableDictionary.cs (65) : return default(T);
HashTableDictionary.cs (66) : }
HashTableDictionary.cs (68) : ListNode<T> node = First;
HashTableDictionary.cs (69) : int i= 0;
HashTableDictionary.cs (70) : while(i < index)
HashTableDictionary.cs (71) : {
HashTableDictionary.cs (72) : node = node.Next;
HashTableDictionary.cs (73) : i++;
HashTableDictionary.cs (74) : }
HashTableDictionary.cs (76) : return node.Value;
HashTableDictionary.cs (78) : }
HashTableDictionary.cs (80) : public void Add(T value)
HashTableDictionary.cs (81) : {
HashTableDictionary.cs (82) : //TODO #3: add a new integer to the end of the list
HashTableDictionary.cs (83) : ListNode<T> node = new ListNode<T>(value);
HashTableDictionary.cs (84) : if (First == null)
HashTableDictionary.cs (85) : {
HashTableDictionary.cs (86) : First = node;
HashTableDictionary.cs (87) : }
HashTableDictionary.cs (88) : else
HashTableDictionary.cs (89) : {
HashTableDictionary.cs (90) : Last.Next = node;
HashTableDictionary.cs (91) : node.Previous = Last;
HashTableDictionary.cs (92) : }
HashTableDictionary.cs (93) : Last = node;
HashTableDictionary.cs (95) : m_numItems++;
HashTableDictionary.cs (96) : }
HashTableDictionary.cs (98) : public T Remove(int index)
HashTableDictionary.cs (99) : {
HashTableDictionary.cs (100) : //TODO #4: remove the element on the index-th position. Do nothing if position is out of bounds
HashTableDictionary.cs (102) : //si estamos fuera de los rangos
HashTableDictionary.cs (103) : if(index < 0 || index >= Count())
HashTableDictionary.cs (104) : {
HashTableDictionary.cs (105) : return default(T);
HashTableDictionary.cs (106) : }
HashTableDictionary.cs (108) : //Si el elemento a eliminar es el primero
HashTableDictionary.cs (109) : if (index == 0)
HashTableDictionary.cs (110) : {
HashTableDictionary.cs (111) : T value1 = First.Value;
HashTableDictionary.cs (112) : First = First.Next;
HashTableDictionary.cs (113) : if (First != null)
HashTableDictionary.cs (114) : {
HashTableDictionary.cs (115) : First.Previous = null;
HashTableDictionary.cs (116) : }
HashTableDictionary.cs (117) : else
HashTableDictionary.cs (118) : {
HashTableDictionary.cs (119) : Last = null;
HashTableDictionary.cs (120) : }
HashTableDictionary.cs (121) : m_numItems--;
HashTableDictionary.cs (122) : return value1;
HashTableDictionary.cs (124) : }
HashTableDictionary.cs (125) : //Si el elemento a eliminar es el último
HashTableDictionary.cs (126) : if (index == Count() - 1)
HashTableDictionary.cs (127) : {
HashTableDictionary.cs (128) : T value2 = Last.Value;
HashTableDictionary.cs (129) : Last = Last.Previous;
HashTableDictionary.cs (130) : if (Last != null)
HashTableDictionary.cs (131) : {
HashTableDictionary.cs (132) : Last.Next = null;
HashTableDictionary.cs (133) : }
HashTableDictionary.cs (134) : else
HashTableDictionary.cs (135) : {
HashTableDictionary.cs (136) : First = null;
HashTableDictionary.cs (137) : }
HashTableDictionary.cs (138) : m_numItems--;
HashTableDictionary.cs (139) : return value2;
HashTableDictionary.cs (140) : }
HashTableDictionary.cs (141) : //Si el elemento a eliminar está en medio
HashTableDictionary.cs (142) : ListNode<T> node = First;
HashTableDictionary.cs (143) : int i = 0;
HashTableDictionary.cs (144) : while (i < index)
HashTableDictionary.cs (145) : {
HashTableDictionary.cs (146) : node = node.Next;
HashTableDictionary.cs (147) : i++;
HashTableDictionary.cs (148) : }
HashTableDictionary.cs (149) : T value = node.Value; //guerdamos el valor de lo que queremos eliminar para devolverlo al final
HashTableDictionary.cs (150) : node.Previous.Next = node.Next; //hacemos que le nodo anterior sea el siguiente del nodo actual
HashTableDictionary.cs (151) : node.Next.Previous = node.Previous; //hacemos que el nodo siguiente sea el anterior del nodo actual
HashTableDictionary.cs (152) : m_numItems--;
HashTableDictionary.cs (153) : return value;
HashTableDictionary.cs (155) : }
HashTableDictionary.cs (157) : public void Clear()
HashTableDictionary.cs (158) : {
HashTableDictionary.cs (159) : //TODO #5: remove all the elements on the list
HashTableDictionary.cs (160) : First = null;
HashTableDictionary.cs (161) : Last = null;
HashTableDictionary.cs (162) : m_numItems = 0;
HashTableDictionary.cs (164) : }
HashTableDictionary.cs (166) : public IEnumerator GetEnumerator()
HashTableDictionary.cs (167) : {
HashTableDictionary.cs (168) : //TODO #6 : Return an enumerator using "yield return" for each of the values in this list
HashTableDictionary.cs (170) : ListNode<T> node = First;
HashTableDictionary.cs (171) : while (node != null)
HashTableDictionary.cs (172) : {
HashTableDictionary.cs (173) : yield return node.Value;
HashTableDictionary.cs (174) : node = node.Next;
HashTableDictionary.cs (175) : }
HashTableDictionary.cs (177) : }
HashTableDictionary.cs (181) : }
HashTableDictionary.cs (182) : private List<HashTableDictionaryItem<TKey, TValue>>[] Entries;
HashTableDictionary.cs (184) : public HashTableDictionary()
HashTableDictionary.cs (185) : {
HashTableDictionary.cs (186) : //TODO #2: Initialize Entries with an array of size DefaultNumEntries
HashTableDictionary.cs (187) : Entries = new List<HashTableDictionaryItem<TKey, TValue>>[DefaultNumEntries];
HashTableDictionary.cs (188) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (189) : {
HashTableDictionary.cs (190) : Entries[i] = new List<HashTableDictionaryItem<TKey, TValue>>();
HashTableDictionary.cs (191) : }
HashTableDictionary.cs (193) : }
HashTableDictionary.cs (195) : public HashTableDictionary(int numEntries)
HashTableDictionary.cs (196) : {
HashTableDictionary.cs (197) : //TODO #2: Initialize Entries with a specific number of entries (numEntries)
HashTableDictionary.cs (198) : Entries = new List<HashTableDictionaryItem<TKey, TValue>>[numEntries];
HashTableDictionary.cs (199) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (200) : {
HashTableDictionary.cs (201) : Entries[i] = new List<HashTableDictionaryItem<TKey, TValue>>();
HashTableDictionary.cs (202) : }
HashTableDictionary.cs (204) : }
HashTableDictionary.cs (206) : public override string ToString()
HashTableDictionary.cs (207) : {
HashTableDictionary.cs (208) : string output = null;
HashTableDictionary.cs (210) : //TODO #3: Uncomment the code below
HashTableDictionary.cs (212) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (213) : {
HashTableDictionary.cs (214) : if (Entries[i] != null)
HashTableDictionary.cs (215) : {
HashTableDictionary.cs (216) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (217) : {
HashTableDictionary.cs (218) : HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (219) : output += entry.ToString();
HashTableDictionary.cs (220) : }
HashTableDictionary.cs (221) : }
HashTableDictionary.cs (222) : }
HashTableDictionary.cs (225) : return output;
HashTableDictionary.cs (226) : }
HashTableDictionary.cs (228) : public int Count()
HashTableDictionary.cs (229) : {
HashTableDictionary.cs (230) : //TODO #4: Return the number of elements (NumElements: make sure this member variable/attribute is updated when the number of elements changes)
HashTableDictionary.cs (232) : return NumElements;
HashTableDictionary.cs (234) : }
HashTableDictionary.cs (236) : public int PositionOf(TKey key)
HashTableDictionary.cs (237) : {
HashTableDictionary.cs (238) : //TODO #5:  Calculate in which entry should this key be stored and return it (use key.GetHashCode() to calculate the hash function of the key)
HashTableDictionary.cs (239) : //          Note:  GetHashCode() returns very large integer numbers, but we need to map this value to the range [0, Entries.Length-1]
HashTableDictionary.cs (241) : int hash = key.GetHashCode();
HashTableDictionary.cs (242) : int position = Math.Abs(hash) % Entries.Length;
HashTableDictionary.cs (243) : return position;
HashTableDictionary.cs (245) : }
HashTableDictionary.cs (247) : public TValue Get(TKey key)
HashTableDictionary.cs (248) : {
HashTableDictionary.cs (249) : //TODO #5:  Using PositionOf, calculate where this key should be in the array of entries and, then,
HashTableDictionary.cs (250) : //          find the item with this key on the list, and return its value
HashTableDictionary.cs (252) : int position = PositionOf(key);
HashTableDictionary.cs (253) : List<HashTableDictionaryItem<TKey, TValue>> list = Entries[position];
HashTableDictionary.cs (254) : for (int i = 0; i < list.Count(); i++)
HashTableDictionary.cs (255) : {
HashTableDictionary.cs (256) : HashTableDictionaryItem<TKey, TValue> item = list.Get(i);
HashTableDictionary.cs (257) : if (item.Key.Equals(key))
HashTableDictionary.cs (258) : {
HashTableDictionary.cs (259) : return item.Value;
HashTableDictionary.cs (260) : }
HashTableDictionary.cs (261) : }
HashTableDictionary.cs (262) : return default(TValue);
HashTableDictionary.cs (263) : }
HashTableDictionary.cs (265) : public void Add(TKey key, TValue value)
HashTableDictionary.cs (266) : {
HashTableDictionary.cs (267) : //TODO #5:  Using PositionOf, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (268) : //          - If the item is not found, add a new item to the list with the given key/value
HashTableDictionary.cs (269) : //          - If the item is found, just update its value
HashTableDictionary.cs (271) : int position = PositionOf(key);
HashTableDictionary.cs (272) : List<HashTableDictionaryItem<TKey, TValue>> list = Entries[position];
HashTableDictionary.cs (273) : for (int i = 0; i < list.Count(); i++)
HashTableDictionary.cs (274) : {
HashTableDictionary.cs (275) : HashTableDictionaryItem<TKey, TValue> item = list.Get(i);
HashTableDictionary.cs (276) : if (item.Key.Equals(key))
HashTableDictionary.cs (277) : {
HashTableDictionary.cs (278) : item.Value = value;
HashTableDictionary.cs (279) : return;
HashTableDictionary.cs (280) : }
HashTableDictionary.cs (281) : }
HashTableDictionary.cs (282) : HashTableDictionaryItem<TKey, TValue> newItem = new HashTableDictionaryItem<TKey, TValue>(key, value);
HashTableDictionary.cs (283) : list.Add(newItem);
HashTableDictionary.cs (284) : NumElements++;
HashTableDictionary.cs (286) : }
HashTableDictionary.cs (288) : public void Remove(TKey key)
HashTableDictionary.cs (289) : {
HashTableDictionary.cs (290) : //TODO #6: Using Position, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (291) : //         - If the item is not found, do nothing
HashTableDictionary.cs (292) : //         - If the item is found, remove it from the list and return
HashTableDictionary.cs (293) : int position = PositionOf(key);
HashTableDictionary.cs (294) : List<HashTableDictionaryItem<TKey, TValue>> list = Entries[position];
HashTableDictionary.cs (295) : for (int i = 0; i < list.Count(); i++)
HashTableDictionary.cs (296) : {
HashTableDictionary.cs (297) : HashTableDictionaryItem<TKey, TValue> item = list.Get(i);
HashTableDictionary.cs (298) : if (item.Key.Equals(key))
HashTableDictionary.cs (299) : {
HashTableDictionary.cs (300) : list.Remove(i);
HashTableDictionary.cs (301) : NumElements--;
HashTableDictionary.cs (302) : return;
HashTableDictionary.cs (303) : }
HashTableDictionary.cs (304) : }
HashTableDictionary.cs (306) : }
HashTableDictionary.cs (308) : public TKey[] Keys()
HashTableDictionary.cs (309) : {
HashTableDictionary.cs (310) : //TODO #8: Return all the keys (not necessarily ordered) in an array
HashTableDictionary.cs (311) : //         If there is no element, it should return an empty array (size=0)
HashTableDictionary.cs (313) : TKey[] keys = new TKey[NumElements];
HashTableDictionary.cs (314) : int index = 0;
HashTableDictionary.cs (315) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (316) : {
HashTableDictionary.cs (317) : if (Entries[i] != null)
HashTableDictionary.cs (318) : {
HashTableDictionary.cs (319) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (320) : {
HashTableDictionary.cs (321) : HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (322) : keys[index] = entry.Key;
HashTableDictionary.cs (323) : index++;
HashTableDictionary.cs (324) : }
HashTableDictionary.cs (325) : }
HashTableDictionary.cs (326) : }
HashTableDictionary.cs (327) : return keys;
HashTableDictionary.cs (328) : }
HashTableDictionary.cs (330) : public TValue[] Values()
HashTableDictionary.cs (331) : {
HashTableDictionary.cs (332) : //TODO #9: Return all the values (in the same order as the keys) in an array
HashTableDictionary.cs (333) : //         If there is no element, it should return an empty array (size=0)
HashTableDictionary.cs (335) : TValue[] values = new TValue[NumElements];
HashTableDictionary.cs (336) : int index = 0;
HashTableDictionary.cs (337) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (338) : {
HashTableDictionary.cs (339) : if (Entries[i] != null)
HashTableDictionary.cs (340) : {
HashTableDictionary.cs (341) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (342) : {
HashTableDictionary.cs (343) : HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (344) : values[index] = entry.Value;
HashTableDictionary.cs (345) : index++;
HashTableDictionary.cs (346) : }
HashTableDictionary.cs (347) : }
HashTableDictionary.cs (348) : }
HashTableDictionary.cs (349) : return values;
HashTableDictionary.cs (351) : }
HashTableDictionary.cs (352) : }
HashTableDictionaryItem.cs (1) : public class HashTableDictionaryItem<TKey, TValue>
HashTableDictionaryItem.cs (2) : {
HashTableDictionaryItem.cs (3) : public TKey Key;
HashTableDictionaryItem.cs (4) : public TValue Value;
HashTableDictionaryItem.cs (6) : public HashTableDictionaryItem(TKey key, TValue value)
HashTableDictionaryItem.cs (7) : {
HashTableDictionaryItem.cs (8) : Key = key;
HashTableDictionaryItem.cs (9) : Value = value;
HashTableDictionaryItem.cs (10) : }
HashTableDictionaryItem.cs (12) : public override string ToString()
HashTableDictionaryItem.cs (13) : {
HashTableDictionaryItem.cs (14) : if (!Key.Equals(default(TKey)))
HashTableDictionaryItem.cs (15) : return $"[{Key}->{Value}]\n";
HashTableDictionaryItem.cs (16) : else
HashTableDictionaryItem.cs (17) : return null;
HashTableDictionaryItem.cs (18) : }
HashTableDictionaryItem.cs (19) : }
UnDirectedGraph.cs (2) : using Common;
UnDirectedGraph.cs (11) : protected HashTableDictionary<TElement, Vertex<TElement, TWeight>> Vertices;
UnDirectedGraph.cs (12) : public UndirectedGraph()
UnDirectedGraph.cs (13) : {
UnDirectedGraph.cs (14) : Vertices = new HashTableDictionary<TElement, Vertex<TElement, TWeight>>();
UnDirectedGraph.cs (16) : }
UnDirectedGraph.cs (23) : string result = "";
UnDirectedGraph.cs (24) : Vertex<TElement, TWeight> [] values = this.Vertices.Values();
UnDirectedGraph.cs (25) : if(values != null)
UnDirectedGraph.cs (26) : {
UnDirectedGraph.cs (27) : for (int i = 0; i < values.Length; i++)
UnDirectedGraph.cs (28) : {
UnDirectedGraph.cs (29) : result += values[i].ToString() + "\n";
UnDirectedGraph.cs (30) : }
UnDirectedGraph.cs (31) : }
UnDirectedGraph.cs (32) : return result;
UnDirectedGraph.cs (39) : TElement[] elements = new TElement[Vertices.Count()];
UnDirectedGraph.cs (40) : Vertices.Keys().CopyTo(elements, 0);
UnDirectedGraph.cs (41) : return elements;
UnDirectedGraph.cs (48) : Vertex<TElement, TWeight> newVertex = new Vertex<TElement, TWeight>(element);
UnDirectedGraph.cs (49) : Vertices.Add(element, newVertex);
UnDirectedGraph.cs (56) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(source);
UnDirectedGraph.cs (57) : sourceVertex.AddEdge(destination, weight);
UnDirectedGraph.cs (58) : Vertex<TElement, TWeight> destinationVertex = Vertices.Get(destination);
UnDirectedGraph.cs (59) : destinationVertex.AddEdge(source, weight);
UnDirectedGraph.cs (67) : return Vertices.Count();
UnDirectedGraph.cs (75) : int edgeCount = 0;
UnDirectedGraph.cs (76) : Vertex<TElement, TWeight>[] values = this.Vertices.Values();
UnDirectedGraph.cs (77) : if(values != null)
UnDirectedGraph.cs (78) : {
UnDirectedGraph.cs (79) : for (int i = 0; i < values.Length; i++)
UnDirectedGraph.cs (80) : {
UnDirectedGraph.cs (81) : edgeCount += values[i].EdgeCount();
UnDirectedGraph.cs (82) : }
UnDirectedGraph.cs (83) : }
UnDirectedGraph.cs (84) : return edgeCount;
UnDirectedGraph.cs (92) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(source);
UnDirectedGraph.cs (93) : return sourceVertex.GetEdgeWeight(destination);
UnDirectedGraph.cs (100) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(source);
UnDirectedGraph.cs (101) : sourceVertex.RemoveEdge(destination);
UnDirectedGraph.cs (102) : Vertex<TElement, TWeight> destinationVertex = Vertices.Get(destination);
UnDirectedGraph.cs (103) : destinationVertex.RemoveEdge(source);
UnDirectedGraph.cs (111) : Vertex<TElement, TWeight> vertexToRemove = Vertices.Get(element);
UnDirectedGraph.cs (112) : TElement[] connectedElements = vertexToRemove.ConnectedElements();
UnDirectedGraph.cs (113) : for (int i = 0; i < connectedElements.Length; i++)
UnDirectedGraph.cs (114) : {
UnDirectedGraph.cs (115) : this.RemoveEdge(element, connectedElements[i]);
UnDirectedGraph.cs (116) : }
UnDirectedGraph.cs (117) : Vertices.Remove(element);
UnDirectedGraph.cs (126) : return Vertices.Get(element);
Vertex.cs (10) : //se usa diccionario para almacenar los edges con la clave siendo el elemento destino y el valor siendo el peso que forman parte de Vertex
Vertex.cs (11) : HashTableDictionary<TElement, TWeight> edges;
Vertex.cs (18) : this.Element = element;
Vertex.cs (19) : edges = new HashTableDictionary<TElement, TWeight>();
Vertex.cs (27) : //crea un array del tamaño del número de edges y copia las claves del diccionario (elementos destino) en el array
Vertex.cs (28) : TElement[] connectedElements = new TElement[EdgeCount()];
Vertex.cs (29) : //con el CopyTo se copian las claves del diccionario edges al array connectedElements, empezando en la posición 0 del array
Vertex.cs (30) : this.edges.Keys().CopyTo(connectedElements, 0);
Vertex.cs (31) : return connectedElements;
Vertex.cs (39) : this.edges.Add(targetElement, weight);
Vertex.cs (47) : return this.edges.Count();
Vertex.cs (54) : this.edges.Remove(targetElement);
Vertex.cs (62) : return this.edges.Get(targetElement);
Vertex.cs (75) : string result = "";
Vertex.cs (76) : TElement[] targets = ConnectedElements();
Vertex.cs (77) : foreach (TElement target in targets)
Vertex.cs (78) : {
Vertex.cs (79) : TWeight weight = GetEdgeWeight(target);
Vertex.cs (80) : result += this.Element + "->" + weight.ToString() + "->" + target + "\n";
Vertex.cs (81) : }
Vertex.cs (82) : return result;
