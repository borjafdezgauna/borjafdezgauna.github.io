DirectedGraph.cs (9) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(sourceKey);
DirectedGraph.cs (10) : sourceVertex.AddEdge(destinationKey, weight);
DirectedGraph.cs (18) : Vertex<TElement, TWeight> vertexToRemove = Vertices.Get(element);
DirectedGraph.cs (19) : //Eliminar todas las aristas que salen de este vértice a otros vértices
DirectedGraph.cs (20) : TElement[] connectedElements = vertexToRemove.ConnectedElements();
DirectedGraph.cs (21) : for (int i = 0; i < connectedElements.Length; i++)
DirectedGraph.cs (22) : {
DirectedGraph.cs (23) : vertexToRemove.RemoveEdge(connectedElements[i]);
DirectedGraph.cs (24) : }
DirectedGraph.cs (25) : //Eliminar las aristas que entran a este vértice desde otros vértices
DirectedGraph.cs (26) : Vertex<TElement, TWeight>[] enteringVertex = Vertices.Values();
DirectedGraph.cs (27) : for (int i = 0; i < enteringVertex.Length; i++)
DirectedGraph.cs (28) : {
DirectedGraph.cs (29) : enteringVertex[i].RemoveEdge(element);
DirectedGraph.cs (30) : }
DirectedGraph.cs (31) : //Finalmente, eliminar el vértice del grafo
DirectedGraph.cs (32) : Vertices.Remove(element);
DirectedGraph.cs (39) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(sourceKey);
DirectedGraph.cs (40) : sourceVertex.RemoveEdge(destKey);
HashTableDictionary.cs (1) : using System;
HashTableDictionary.cs (2) : using System.Collections;
HashTableDictionary.cs (3) : using Common;
HashTableDictionary.cs (5) : public class HashTableDictionary<TKey, TValue> : IDictionary<TKey, TValue>
HashTableDictionary.cs (6) : {
HashTableDictionary.cs (7) : int DefaultNumEntries = 10000;
HashTableDictionary.cs (8) : int NumElements = 0;
HashTableDictionary.cs (9) : //TODO #1: Copy your implementation of List to the project HashTableDictionary and use it to declare Entries: an array of lists of HashTableDictionaryItem<TKey,TValue>
HashTableDictionary.cs (10) : //[USE List and HashTableDictionaryItem HERE] [] Entries;
HashTableDictionary.cs (11) : public class ListNode<T>
HashTableDictionary.cs (12) : {
HashTableDictionary.cs (13) : public T Value;
HashTableDictionary.cs (14) : public ListNode<T> Next = null;
HashTableDictionary.cs (15) : public ListNode<T> Previous = null;
HashTableDictionary.cs (18) : public ListNode(T value)
HashTableDictionary.cs (19) : {
HashTableDictionary.cs (20) : Value = value;
HashTableDictionary.cs (21) : }
HashTableDictionary.cs (23) : public override string ToString()
HashTableDictionary.cs (24) : {
HashTableDictionary.cs (25) : return Value.ToString();
HashTableDictionary.cs (26) : }
HashTableDictionary.cs (27) : }
HashTableDictionary.cs (29) : public class List<T>
HashTableDictionary.cs (30) : {
HashTableDictionary.cs (31) : ListNode<T> First = null;
HashTableDictionary.cs (32) : ListNode<T> Last = null;
HashTableDictionary.cs (34) : int m_numItems = 0;
HashTableDictionary.cs (36) : public override string ToString()
HashTableDictionary.cs (37) : {
HashTableDictionary.cs (38) : ListNode<T> node = First;
HashTableDictionary.cs (39) : string output = "[";
HashTableDictionary.cs (41) : while (node != null)
HashTableDictionary.cs (42) : {
HashTableDictionary.cs (43) : output += node.ToString() + ",";
HashTableDictionary.cs (44) : node = node.Next;
HashTableDictionary.cs (45) : }
HashTableDictionary.cs (46) : output = output.TrimEnd(',') + "] " + Count() + " elements";
HashTableDictionary.cs (48) : return output;
HashTableDictionary.cs (49) : }
HashTableDictionary.cs (51) : public int Count()
HashTableDictionary.cs (52) : {
HashTableDictionary.cs (53) : //TODO #1: return the number of elements on the list
HashTableDictionary.cs (55) : return m_numItems;
HashTableDictionary.cs (57) : }
HashTableDictionary.cs (59) : public T Get(int index)
HashTableDictionary.cs (60) : {
HashTableDictionary.cs (61) : //TODO #2: return the element on the index-th position. O if the position is out of bounds
HashTableDictionary.cs (63) : if(index < 0 || index >= Count())
HashTableDictionary.cs (64) : {
HashTableDictionary.cs (65) : return default(T);
HashTableDictionary.cs (66) : }
HashTableDictionary.cs (68) : ListNode<T> node = First;
HashTableDictionary.cs (69) : int i= 0;
HashTableDictionary.cs (70) : while(i < index)
HashTableDictionary.cs (71) : {
HashTableDictionary.cs (72) : node = node.Next;
HashTableDictionary.cs (73) : i++;
HashTableDictionary.cs (74) : }
HashTableDictionary.cs (76) : return node.Value;
HashTableDictionary.cs (78) : }
HashTableDictionary.cs (80) : public void Add(T value)
HashTableDictionary.cs (81) : {
HashTableDictionary.cs (82) : //TODO #3: add a new integer to the end of the list
HashTableDictionary.cs (83) : ListNode<T> node = new ListNode<T>(value);
HashTableDictionary.cs (84) : if (First == null)
HashTableDictionary.cs (85) : {
HashTableDictionary.cs (86) : First = node;
HashTableDictionary.cs (87) : }
HashTableDictionary.cs (88) : else
HashTableDictionary.cs (89) : {
HashTableDictionary.cs (90) : Last.Next = node;
HashTableDictionary.cs (91) : node.Previous = Last;
HashTableDictionary.cs (92) : }
HashTableDictionary.cs (93) : Last = node;
HashTableDictionary.cs (95) : m_numItems++;
HashTableDictionary.cs (96) : }
HashTableDictionary.cs (98) : public T Remove(int index)
HashTableDictionary.cs (99) : {
HashTableDictionary.cs (100) : //TODO #4: remove the element on the index-th position. Do nothing if position is out of bounds
HashTableDictionary.cs (102) : //si estamos fuera de los rangos
HashTableDictionary.cs (103) : if(index < 0 || index >= Count())
HashTableDictionary.cs (104) : {
HashTableDictionary.cs (105) : return default(T);
HashTableDictionary.cs (106) : }
HashTableDictionary.cs (108) : //Si el elemento a eliminar es el primero
HashTableDictionary.cs (109) : if (index == 0)
HashTableDictionary.cs (110) : {
HashTableDictionary.cs (111) : T value1 = First.Value;
HashTableDictionary.cs (112) : First = First.Next;
HashTableDictionary.cs (113) : if (First != null)
HashTableDictionary.cs (114) : {
HashTableDictionary.cs (115) : First.Previous = null;
HashTableDictionary.cs (116) : }
HashTableDictionary.cs (117) : else
HashTableDictionary.cs (118) : {
HashTableDictionary.cs (119) : Last = null;
HashTableDictionary.cs (120) : }
HashTableDictionary.cs (121) : m_numItems--;
HashTableDictionary.cs (122) : return value1;
HashTableDictionary.cs (124) : }
HashTableDictionary.cs (125) : //Si el elemento a eliminar es el último
HashTableDictionary.cs (126) : if (index == Count() - 1)
HashTableDictionary.cs (127) : {
HashTableDictionary.cs (128) : T value2 = Last.Value;
HashTableDictionary.cs (129) : Last = Last.Previous;
HashTableDictionary.cs (130) : if (Last != null)
HashTableDictionary.cs (131) : {
HashTableDictionary.cs (132) : Last.Next = null;
HashTableDictionary.cs (133) : }
HashTableDictionary.cs (134) : else
HashTableDictionary.cs (135) : {
HashTableDictionary.cs (136) : First = null;
HashTableDictionary.cs (137) : }
HashTableDictionary.cs (138) : m_numItems--;
HashTableDictionary.cs (139) : return value2;
HashTableDictionary.cs (140) : }
HashTableDictionary.cs (141) : //Si el elemento a eliminar está en medio
HashTableDictionary.cs (142) : ListNode<T> node = First;
HashTableDictionary.cs (143) : int i = 0;
HashTableDictionary.cs (144) : while (i < index)
HashTableDictionary.cs (145) : {
HashTableDictionary.cs (146) : node = node.Next;
HashTableDictionary.cs (147) : i++;
HashTableDictionary.cs (148) : }
HashTableDictionary.cs (149) : T value = node.Value; //guerdamos el valor de lo que queremos eliminar para devolverlo al final
HashTableDictionary.cs (150) : node.Previous.Next = node.Next; //hacemos que le nodo anterior sea el siguiente del nodo actual
HashTableDictionary.cs (151) : node.Next.Previous = node.Previous; //hacemos que el nodo siguiente sea el anterior del nodo actual
HashTableDictionary.cs (152) : m_numItems--;
HashTableDictionary.cs (153) : return value;
HashTableDictionary.cs (155) : }
HashTableDictionary.cs (157) : public void Clear()
HashTableDictionary.cs (158) : {
HashTableDictionary.cs (159) : //TODO #5: remove all the elements on the list
HashTableDictionary.cs (160) : First = null;
HashTableDictionary.cs (161) : Last = null;
HashTableDictionary.cs (162) : m_numItems = 0;
HashTableDictionary.cs (164) : }
HashTableDictionary.cs (166) : public IEnumerator GetEnumerator()
HashTableDictionary.cs (167) : {
HashTableDictionary.cs (168) : //TODO #6 : Return an enumerator using "yield return" for each of the values in this list
HashTableDictionary.cs (170) : ListNode<T> node = First;
HashTableDictionary.cs (171) : while (node != null)
HashTableDictionary.cs (172) : {
HashTableDictionary.cs (173) : yield return node.Value;
HashTableDictionary.cs (174) : node = node.Next;
HashTableDictionary.cs (175) : }
HashTableDictionary.cs (177) : }
HashTableDictionary.cs (181) : }
HashTableDictionary.cs (182) : private List<HashTableDictionaryItem<TKey, TValue>>[] Entries;
HashTableDictionary.cs (184) : public HashTableDictionary()
HashTableDictionary.cs (185) : {
HashTableDictionary.cs (186) : //TODO #2: Initialize Entries with an array of size DefaultNumEntries
HashTableDictionary.cs (187) : Entries = new List<HashTableDictionaryItem<TKey, TValue>>[DefaultNumEntries];
HashTableDictionary.cs (188) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (189) : {
HashTableDictionary.cs (190) : Entries[i] = new List<HashTableDictionaryItem<TKey, TValue>>();
HashTableDictionary.cs (191) : }
HashTableDictionary.cs (193) : }
HashTableDictionary.cs (195) : public HashTableDictionary(int numEntries)
HashTableDictionary.cs (196) : {
HashTableDictionary.cs (197) : //TODO #2: Initialize Entries with a specific number of entries (numEntries)
HashTableDictionary.cs (198) : Entries = new List<HashTableDictionaryItem<TKey, TValue>>[numEntries];
HashTableDictionary.cs (199) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (200) : {
HashTableDictionary.cs (201) : Entries[i] = new List<HashTableDictionaryItem<TKey, TValue>>();
HashTableDictionary.cs (202) : }
HashTableDictionary.cs (204) : }
HashTableDictionary.cs (206) : public override string ToString()
HashTableDictionary.cs (207) : {
HashTableDictionary.cs (208) : string output = null;
HashTableDictionary.cs (210) : //TODO #3: Uncomment the code below
HashTableDictionary.cs (212) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (213) : {
HashTableDictionary.cs (214) : if (Entries[i] != null)
HashTableDictionary.cs (215) : {
HashTableDictionary.cs (216) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (217) : {
HashTableDictionary.cs (218) : HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (219) : output += entry.ToString();
HashTableDictionary.cs (220) : }
HashTableDictionary.cs (221) : }
HashTableDictionary.cs (222) : }
HashTableDictionary.cs (225) : return output;
HashTableDictionary.cs (226) : }
HashTableDictionary.cs (228) : public int Count()
HashTableDictionary.cs (229) : {
HashTableDictionary.cs (230) : //TODO #4: Return the number of elements (NumElements: make sure this member variable/attribute is updated when the number of elements changes)
HashTableDictionary.cs (232) : return NumElements;
HashTableDictionary.cs (234) : }
HashTableDictionary.cs (236) : public int PositionOf(TKey key)
HashTableDictionary.cs (237) : {
HashTableDictionary.cs (238) : //TODO #5:  Calculate in which entry should this key be stored and return it (use key.GetHashCode() to calculate the hash function of the key)
HashTableDictionary.cs (239) : //          Note:  GetHashCode() returns very large integer numbers, but we need to map this value to the range [0, Entries.Length-1]
HashTableDictionary.cs (241) : int hash = key.GetHashCode();
HashTableDictionary.cs (242) : int position = Math.Abs(hash) % Entries.Length;
HashTableDictionary.cs (243) : return position;
HashTableDictionary.cs (245) : }
HashTableDictionary.cs (247) : public TValue Get(TKey key)
HashTableDictionary.cs (248) : {
HashTableDictionary.cs (249) : //TODO #5:  Using PositionOf, calculate where this key should be in the array of entries and, then,
HashTableDictionary.cs (250) : //          find the item with this key on the list, and return its value
HashTableDictionary.cs (252) : int position = PositionOf(key);
HashTableDictionary.cs (253) : List<HashTableDictionaryItem<TKey, TValue>> list = Entries[position];
HashTableDictionary.cs (254) : for (int i = 0; i < list.Count(); i++)
HashTableDictionary.cs (255) : {
HashTableDictionary.cs (256) : HashTableDictionaryItem<TKey, TValue> item = list.Get(i);
HashTableDictionary.cs (257) : if (item.Key.Equals(key))
HashTableDictionary.cs (258) : {
HashTableDictionary.cs (259) : return item.Value;
HashTableDictionary.cs (260) : }
HashTableDictionary.cs (261) : }
HashTableDictionary.cs (262) : return default(TValue);
HashTableDictionary.cs (263) : }
HashTableDictionary.cs (265) : public void Add(TKey key, TValue value)
HashTableDictionary.cs (266) : {
HashTableDictionary.cs (267) : //TODO #5:  Using PositionOf, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (268) : //          - If the item is not found, add a new item to the list with the given key/value
HashTableDictionary.cs (269) : //          - If the item is found, just update its value
HashTableDictionary.cs (271) : int position = PositionOf(key);
HashTableDictionary.cs (272) : List<HashTableDictionaryItem<TKey, TValue>> list = Entries[position];
HashTableDictionary.cs (273) : for (int i = 0; i < list.Count(); i++)
HashTableDictionary.cs (274) : {
HashTableDictionary.cs (275) : HashTableDictionaryItem<TKey, TValue> item = list.Get(i);
HashTableDictionary.cs (276) : if (item.Key.Equals(key))
HashTableDictionary.cs (277) : {
HashTableDictionary.cs (278) : item.Value = value;
HashTableDictionary.cs (279) : return;
HashTableDictionary.cs (280) : }
HashTableDictionary.cs (281) : }
HashTableDictionary.cs (282) : HashTableDictionaryItem<TKey, TValue> newItem = new HashTableDictionaryItem<TKey, TValue>(key, value);
HashTableDictionary.cs (283) : list.Add(newItem);
HashTableDictionary.cs (284) : NumElements++;
HashTableDictionary.cs (286) : }
HashTableDictionary.cs (288) : public void Remove(TKey key)
HashTableDictionary.cs (289) : {
HashTableDictionary.cs (290) : //TODO #6: Using Position, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (291) : //         - If the item is not found, do nothing
HashTableDictionary.cs (292) : //         - If the item is found, remove it from the list and return
HashTableDictionary.cs (293) : int position = PositionOf(key);
HashTableDictionary.cs (294) : List<HashTableDictionaryItem<TKey, TValue>> list = Entries[position];
HashTableDictionary.cs (295) : for (int i = 0; i < list.Count(); i++)
HashTableDictionary.cs (296) : {
HashTableDictionary.cs (297) : HashTableDictionaryItem<TKey, TValue> item = list.Get(i);
HashTableDictionary.cs (298) : if (item.Key.Equals(key))
HashTableDictionary.cs (299) : {
HashTableDictionary.cs (300) : list.Remove(i);
HashTableDictionary.cs (301) : NumElements--;
HashTableDictionary.cs (302) : return;
HashTableDictionary.cs (303) : }
HashTableDictionary.cs (304) : }
HashTableDictionary.cs (306) : }
HashTableDictionary.cs (308) : public TKey[] Keys()
HashTableDictionary.cs (309) : {
HashTableDictionary.cs (310) : //TODO #8: Return all the keys (not necessarily ordered) in an array
HashTableDictionary.cs (311) : //         If there is no element, it should return an empty array (size=0)
HashTableDictionary.cs (313) : TKey[] keys = new TKey[NumElements];
HashTableDictionary.cs (314) : int index = 0;
HashTableDictionary.cs (315) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (316) : {
HashTableDictionary.cs (317) : if (Entries[i] != null)
HashTableDictionary.cs (318) : {
HashTableDictionary.cs (319) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (320) : {
HashTableDictionary.cs (321) : HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (322) : keys[index] = entry.Key;
HashTableDictionary.cs (323) : index++;
HashTableDictionary.cs (324) : }
HashTableDictionary.cs (325) : }
HashTableDictionary.cs (326) : }
HashTableDictionary.cs (327) : return keys;
HashTableDictionary.cs (328) : }
HashTableDictionary.cs (330) : public TValue[] Values()
HashTableDictionary.cs (331) : {
HashTableDictionary.cs (332) : //TODO #9: Return all the values (in the same order as the keys) in an array
HashTableDictionary.cs (333) : //         If there is no element, it should return an empty array (size=0)
HashTableDictionary.cs (335) : TValue[] values = new TValue[NumElements];
HashTableDictionary.cs (336) : int index = 0;
HashTableDictionary.cs (337) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (338) : {
HashTableDictionary.cs (339) : if (Entries[i] != null)
HashTableDictionary.cs (340) : {
HashTableDictionary.cs (341) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (342) : {
HashTableDictionary.cs (343) : HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (344) : values[index] = entry.Value;
HashTableDictionary.cs (345) : index++;
HashTableDictionary.cs (346) : }
HashTableDictionary.cs (347) : }
HashTableDictionary.cs (348) : }
HashTableDictionary.cs (349) : return values;
HashTableDictionary.cs (351) : }
HashTableDictionary.cs (352) : }
HashTableDictionaryItem.cs (1) : public class HashTableDictionaryItem<TKey, TValue>
HashTableDictionaryItem.cs (2) : {
HashTableDictionaryItem.cs (3) : public TKey Key;
HashTableDictionaryItem.cs (4) : public TValue Value;
HashTableDictionaryItem.cs (6) : public HashTableDictionaryItem(TKey key, TValue value)
HashTableDictionaryItem.cs (7) : {
HashTableDictionaryItem.cs (8) : Key = key;
HashTableDictionaryItem.cs (9) : Value = value;
HashTableDictionaryItem.cs (10) : }
HashTableDictionaryItem.cs (12) : public override string ToString()
HashTableDictionaryItem.cs (13) : {
HashTableDictionaryItem.cs (14) : if (!Key.Equals(default(TKey)))
HashTableDictionaryItem.cs (15) : return $"[{Key}->{Value}]\n";
HashTableDictionaryItem.cs (16) : else
HashTableDictionaryItem.cs (17) : return null;
HashTableDictionaryItem.cs (18) : }
HashTableDictionaryItem.cs (19) : }
UnDirectedGraph.cs (2) : using Common;
UnDirectedGraph.cs (11) : protected HashTableDictionary<TElement, Vertex<TElement, TWeight>> Vertices;
UnDirectedGraph.cs (12) : public UndirectedGraph()
UnDirectedGraph.cs (13) : {
UnDirectedGraph.cs (14) : Vertices = new HashTableDictionary<TElement, Vertex<TElement, TWeight>>();
UnDirectedGraph.cs (16) : }
UnDirectedGraph.cs (23) : string result = "";
UnDirectedGraph.cs (24) : Vertex<TElement, TWeight> [] values = this.Vertices.Values();
UnDirectedGraph.cs (25) : if(values != null)
UnDirectedGraph.cs (26) : {
UnDirectedGraph.cs (27) : for (int i = 0; i < values.Length; i++)
UnDirectedGraph.cs (28) : {
UnDirectedGraph.cs (29) : result += values[i].ToString() + "\n";
UnDirectedGraph.cs (30) : }
UnDirectedGraph.cs (31) : }
UnDirectedGraph.cs (32) : return result;
UnDirectedGraph.cs (39) : TElement[] elements = new TElement[Vertices.Count()];
UnDirectedGraph.cs (40) : Vertices.Keys().CopyTo(elements, 0);
UnDirectedGraph.cs (41) : return elements;
UnDirectedGraph.cs (48) : Vertex<TElement, TWeight> newVertex = new Vertex<TElement, TWeight>(element);
UnDirectedGraph.cs (49) : Vertices.Add(element, newVertex);
UnDirectedGraph.cs (56) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(source);
UnDirectedGraph.cs (57) : sourceVertex.AddEdge(destination, weight);
UnDirectedGraph.cs (58) : Vertex<TElement, TWeight> destinationVertex = Vertices.Get(destination);
UnDirectedGraph.cs (59) : destinationVertex.AddEdge(source, weight);
UnDirectedGraph.cs (67) : return Vertices.Count();
UnDirectedGraph.cs (75) : int edgeCount = 0;
UnDirectedGraph.cs (76) : Vertex<TElement, TWeight>[] values = this.Vertices.Values();
UnDirectedGraph.cs (77) : if(values != null)
UnDirectedGraph.cs (78) : {
UnDirectedGraph.cs (79) : for (int i = 0; i < values.Length; i++)
UnDirectedGraph.cs (80) : {
UnDirectedGraph.cs (81) : edgeCount += values[i].EdgeCount();
UnDirectedGraph.cs (82) : }
UnDirectedGraph.cs (83) : }
UnDirectedGraph.cs (84) : return edgeCount;
UnDirectedGraph.cs (92) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(source);
UnDirectedGraph.cs (93) : return sourceVertex.GetEdgeWeight(destination);
UnDirectedGraph.cs (100) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(source);
UnDirectedGraph.cs (101) : sourceVertex.RemoveEdge(destination);
UnDirectedGraph.cs (102) : Vertex<TElement, TWeight> destinationVertex = Vertices.Get(destination);
UnDirectedGraph.cs (103) : destinationVertex.RemoveEdge(source);
UnDirectedGraph.cs (111) : Vertex<TElement, TWeight> vertexToRemove = Vertices.Get(element);
UnDirectedGraph.cs (112) : TElement[] connectedElements = vertexToRemove.ConnectedElements();
UnDirectedGraph.cs (113) : for (int i = 0; i < connectedElements.Length; i++)
UnDirectedGraph.cs (114) : {
UnDirectedGraph.cs (115) : this.RemoveEdge(element, connectedElements[i]);
UnDirectedGraph.cs (116) : }
UnDirectedGraph.cs (117) : Vertices.Remove(element);
UnDirectedGraph.cs (126) : return Vertices.Get(element);
Vertex.cs (10) : //se usa diccionario para almacenar los edges con la clave siendo el elemento destino y el valor siendo el peso que forman parte de Vertex
Vertex.cs (11) : HashTableDictionary<TElement, TWeight> edges;
Vertex.cs (18) : this.Element = element;
Vertex.cs (19) : edges = new HashTableDictionary<TElement, TWeight>();
Vertex.cs (27) : //crea un array del tamaño del número de edges y copia las claves del diccionario (elementos destino) en el array
Vertex.cs (28) : TElement[] connectedElements = new TElement[EdgeCount()];
Vertex.cs (29) : //con el CopyTo se copian las claves del diccionario edges al array connectedElements, empezando en la posición 0 del array
Vertex.cs (30) : this.edges.Keys().CopyTo(connectedElements, 0);
Vertex.cs (31) : return connectedElements;
Vertex.cs (39) : this.edges.Add(targetElement, weight);
Vertex.cs (47) : return this.edges.Count();
Vertex.cs (54) : this.edges.Remove(targetElement);
Vertex.cs (62) : return this.edges.Get(targetElement);
Vertex.cs (75) : string result = "";
Vertex.cs (76) : TElement[] targets = ConnectedElements();
Vertex.cs (77) : foreach (TElement target in targets)
Vertex.cs (78) : {
Vertex.cs (79) : TWeight weight = GetEdgeWeight(target);
Vertex.cs (80) : result += this.Element + "->" + weight.ToString() + "->" + target + "\n";
Vertex.cs (81) : }
Vertex.cs (82) : return result;
