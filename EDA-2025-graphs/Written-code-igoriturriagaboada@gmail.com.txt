BinaryGraphReaderWriter.cs (17) : // Write number of vertices
BinaryGraphReaderWriter.cs (18) : TKey[] keys = graph.Elements();
BinaryGraphReaderWriter.cs (19) : writer.Write(keys.Length);
BinaryGraphReaderWriter.cs (21) : // Write each key: length + bytes
BinaryGraphReaderWriter.cs (22) : for (int i = 0; i < keys.Length; i++)
BinaryGraphReaderWriter.cs (23) : {
BinaryGraphReaderWriter.cs (24) : byte[] keyBytes = keyToByteArray(keys[i]);
BinaryGraphReaderWriter.cs (25) : writer.Write(keyBytes.Length);
BinaryGraphReaderWriter.cs (26) : writer.Write(keyBytes);
BinaryGraphReaderWriter.cs (27) : }
BinaryGraphReaderWriter.cs (29) : // Write number of stored edges (we write all stored edges, including both directions for undirected graphs)
BinaryGraphReaderWriter.cs (30) : int edgeCount = graph.EdgeCount();
BinaryGraphReaderWriter.cs (31) : writer.Write(edgeCount);
BinaryGraphReaderWriter.cs (33) : // For each stored edge: write source key, weight, destination key (each as length + bytes)
BinaryGraphReaderWriter.cs (34) : for (int i = 0; i < keys.Length; i++)
BinaryGraphReaderWriter.cs (35) : {
BinaryGraphReaderWriter.cs (36) : var vertex = graph.GetVertex(keys[i]);
BinaryGraphReaderWriter.cs (37) : if (vertex == null)
BinaryGraphReaderWriter.cs (38) : continue;
BinaryGraphReaderWriter.cs (40) : TKey sourceKey = vertex.Element;
BinaryGraphReaderWriter.cs (41) : TKey[] targets = vertex.ConnectedElements();
BinaryGraphReaderWriter.cs (42) : for (int j = 0; j < targets.Length; j++)
BinaryGraphReaderWriter.cs (43) : {
BinaryGraphReaderWriter.cs (44) : TKey destKey = targets[j];
BinaryGraphReaderWriter.cs (45) : TWeight weight = vertex.GetEdgeWeight(destKey);
BinaryGraphReaderWriter.cs (47) : byte[] sourceBytes = keyToByteArray(sourceKey);
BinaryGraphReaderWriter.cs (48) : writer.Write(sourceBytes.Length);
BinaryGraphReaderWriter.cs (49) : writer.Write(sourceBytes);
BinaryGraphReaderWriter.cs (51) : byte[] weightBytes = weightToByteArray(weight);
BinaryGraphReaderWriter.cs (52) : writer.Write(weightBytes.Length);
BinaryGraphReaderWriter.cs (53) : writer.Write(weightBytes);
BinaryGraphReaderWriter.cs (55) : byte[] destBytes = keyToByteArray(destKey);
BinaryGraphReaderWriter.cs (56) : writer.Write(destBytes.Length);
BinaryGraphReaderWriter.cs (57) : writer.Write(destBytes);
BinaryGraphReaderWriter.cs (58) : }
BinaryGraphReaderWriter.cs (59) : }
DirectedGraph.cs (9) : var source = Vertices.Get(sourceKey);
DirectedGraph.cs (10) : var dest = Vertices.Get(destinationKey);
DirectedGraph.cs (11) : if (source != null)
DirectedGraph.cs (12) : source.AddEdge(destinationKey, weight);
DirectedGraph.cs (13) : if (dest != null)
DirectedGraph.cs (14) : dest.AddIncoming(sourceKey);
DirectedGraph.cs (20) : // Optimized: use incoming and outgoing lists to avoid scanning all vertices on each removal
DirectedGraph.cs (21) : var v = Vertices.Get(element);
DirectedGraph.cs (22) : if (v == null)
DirectedGraph.cs (23) : return;
DirectedGraph.cs (25) : // Remove references to this vertex from its outgoing neighbors' incoming lists
DirectedGraph.cs (26) : TElement[] outNeighbors = v.ConnectedElements();
DirectedGraph.cs (27) : for (int i = 0; i < outNeighbors.Length; i++)
DirectedGraph.cs (28) : {
DirectedGraph.cs (29) : var dest = Vertices.Get(outNeighbors[i]);
DirectedGraph.cs (30) : if (dest != null)
DirectedGraph.cs (31) : dest.RemoveIncoming(element);
DirectedGraph.cs (32) : }
DirectedGraph.cs (34) : // Remove incoming edges (remove edge from each incoming neighbor to this vertex)
DirectedGraph.cs (35) : TElement[] inNeighbors = v.IncomingElements();
DirectedGraph.cs (36) : for (int i = 0; i < inNeighbors.Length; i++)
DirectedGraph.cs (37) : {
DirectedGraph.cs (38) : var src = Vertices.Get(inNeighbors[i]);
DirectedGraph.cs (39) : if (src != null)
DirectedGraph.cs (40) : src.RemoveEdge(element);
DirectedGraph.cs (41) : }
DirectedGraph.cs (43) : // Finally remove the vertex
DirectedGraph.cs (44) : Vertices.Remove(element);
DirectedGraph.cs (50) : var source = Vertices.Get(sourceKey);
DirectedGraph.cs (51) : var dest = Vertices.Get(destKey);
DirectedGraph.cs (52) : if (source != null)
DirectedGraph.cs (53) : source.RemoveEdge(destKey);
DirectedGraph.cs (54) : if (dest != null)
DirectedGraph.cs (55) : dest.RemoveIncoming(sourceKey);
DistanceCalculator.cs (8) : public UndirectedGraph<String, double> ciudades = new UndirectedGraph<String, double>();
DistanceCalculator.cs (12) : if (isUndirected)
DistanceCalculator.cs (13) : {
DistanceCalculator.cs (14) : ciudades = new UndirectedGraph<String, double>();
DistanceCalculator.cs (15) : }
DistanceCalculator.cs (16) : else
DistanceCalculator.cs (17) : {
DistanceCalculator.cs (18) : ciudades = new DirectedGraph<String, double>();
DistanceCalculator.cs (19) : }
DistanceCalculator.cs (25) : ciudades.AddVertex(city);
DistanceCalculator.cs (31) : ciudades.AddEdge(fromCity, toCity, distance);
DistanceCalculator.cs (37) : // Choose the candidate with the minimum tentative distance that hasn't been visited yet
DistanceCalculator.cs (38) : string[] candidates = nextCityCandidates.Keys();
DistanceCalculator.cs (39) : if (candidates == null || candidates.Length == 0)
DistanceCalculator.cs (42) : string best = null;
DistanceCalculator.cs (43) : double bestDist = double.MaxValue;
DistanceCalculator.cs (44) : for (int i = 0; i < candidates.Length; i++)
DistanceCalculator.cs (45) : {
DistanceCalculator.cs (46) : string c = candidates[i];
DistanceCalculator.cs (47) : bool isVisited = visited.Get(c);
DistanceCalculator.cs (48) : if (isVisited)
DistanceCalculator.cs (49) : continue;
DistanceCalculator.cs (50) : double d = nextCityCandidates.Get(c);
DistanceCalculator.cs (51) : if (d < bestDist)
DistanceCalculator.cs (52) : {
DistanceCalculator.cs (53) : bestDist = d;
DistanceCalculator.cs (54) : best = c;
DistanceCalculator.cs (55) : }
DistanceCalculator.cs (56) : }
DistanceCalculator.cs (58) : if (best != null)
DistanceCalculator.cs (59) : nextCityCandidates.Remove(best);
DistanceCalculator.cs (61) : return best;
DistanceCalculator.cs (67) : // Add neighbours of currentCity to candidates and update distances
DistanceCalculator.cs (68) : var currentVertex = ciudades.GetVertex(currentCity);
DistanceCalculator.cs (69) : if (currentVertex == null)
DistanceCalculator.cs (70) : return;
DistanceCalculator.cs (72) : double currentDist = distanceToCity.Get(currentCity);
DistanceCalculator.cs (73) : if (currentDist.Equals(default(double)))
DistanceCalculator.cs (74) : currentDist = double.MaxValue;
DistanceCalculator.cs (76) : string[] neighbours = currentVertex.ConnectedElements();
DistanceCalculator.cs (77) : for (int i = 0; i < neighbours.Length; i++)
DistanceCalculator.cs (78) : {
DistanceCalculator.cs (79) : string neighbour = neighbours[i];
DistanceCalculator.cs (80) : if (visited.Get(neighbour))
DistanceCalculator.cs (81) : continue;
DistanceCalculator.cs (83) : double edgeWeight = ciudades.GetEdgeWeight(currentCity, neighbour);
DistanceCalculator.cs (84) : double newDist = currentDist + edgeWeight;
DistanceCalculator.cs (86) : double oldDist = distanceToCity.Get(neighbour);
DistanceCalculator.cs (87) : if (oldDist.Equals(default(double)))
DistanceCalculator.cs (88) : oldDist = double.MaxValue;
DistanceCalculator.cs (90) : if (newDist < oldDist)
DistanceCalculator.cs (91) : {
DistanceCalculator.cs (92) : distanceToCity.Add(neighbour, newDist);
DistanceCalculator.cs (93) : nextCityCandidates.Add(neighbour, newDist);
DistanceCalculator.cs (94) : }
DistanceCalculator.cs (95) : }
DistanceCalculator.cs (97) : // Mark current as visited
DistanceCalculator.cs (98) : visited.Add(currentCity, true);
DistanceCalculator.cs (103) : // Simple Dijkstra without heap (O(N^2)), works for the sizes in tests
DistanceCalculator.cs (104) : String[] elements = ciudades.Elements();
DistanceCalculator.cs (105) : int n = elements.Length;
DistanceCalculator.cs (107) : // Map city -> index for O(1) array access
DistanceCalculator.cs (108) : HashTableDictionary<string, int> indexMap = new HashTableDictionary<string, int>();
DistanceCalculator.cs (109) : for (int i = 0; i < n; i++)
DistanceCalculator.cs (110) : indexMap.Add(elements[i], i);
DistanceCalculator.cs (112) : double[] dist = new double[n];
DistanceCalculator.cs (113) : bool[] vis = new bool[n];
DistanceCalculator.cs (114) : for (int i = 0; i < n; i++)
DistanceCalculator.cs (115) : {
DistanceCalculator.cs (116) : dist[i] = double.MaxValue;
DistanceCalculator.cs (117) : vis[i] = false;
DistanceCalculator.cs (118) : }
DistanceCalculator.cs (120) : if (!indexMap.Get(fromCity).Equals(default(int)))
DistanceCalculator.cs (121) : {
DistanceCalculator.cs (122) : int srcIdx = indexMap.Get(fromCity);
DistanceCalculator.cs (123) : dist[srcIdx] = 0;
DistanceCalculator.cs (124) : }
DistanceCalculator.cs (126) : for (int iter = 0; iter < n; iter++)
DistanceCalculator.cs (127) : {
DistanceCalculator.cs (128) : // Find unvisited node with minimal distance
DistanceCalculator.cs (129) : int minIdx = -1;
DistanceCalculator.cs (130) : double minDist = double.MaxValue;
DistanceCalculator.cs (131) : for (int i = 0; i < n; i++)
DistanceCalculator.cs (132) : {
DistanceCalculator.cs (133) : if (vis[i]) continue;
DistanceCalculator.cs (134) : double d = dist[i];
DistanceCalculator.cs (135) : if (d < minDist)
DistanceCalculator.cs (136) : {
DistanceCalculator.cs (137) : minDist = d;
DistanceCalculator.cs (138) : minIdx = i;
DistanceCalculator.cs (139) : }
DistanceCalculator.cs (140) : }
DistanceCalculator.cs (142) : if (minIdx == -1 || minDist == double.MaxValue)
DistanceCalculator.cs (143) : break;
DistanceCalculator.cs (145) : vis[minIdx] = true;
DistanceCalculator.cs (146) : string minCity = elements[minIdx];
DistanceCalculator.cs (147) : var vertex = ciudades.GetVertex(minCity);
DistanceCalculator.cs (148) : if (vertex == null) continue;
DistanceCalculator.cs (150) : string[] neighbours = vertex.ConnectedElements();
DistanceCalculator.cs (151) : for (int j = 0; j < neighbours.Length; j++)
DistanceCalculator.cs (152) : {
DistanceCalculator.cs (153) : string neighbour = neighbours[j];
DistanceCalculator.cs (154) : int nbIdx = indexMap.Get(neighbour);
DistanceCalculator.cs (155) : if (vis[nbIdx]) continue;
DistanceCalculator.cs (156) : double weight = ciudades.GetEdgeWeight(minCity, neighbour);
DistanceCalculator.cs (157) : double newDist = minDist + weight;
DistanceCalculator.cs (158) : if (newDist < dist[nbIdx])
DistanceCalculator.cs (159) : dist[nbIdx] = newDist;
DistanceCalculator.cs (160) : }
DistanceCalculator.cs (161) : }
DistanceCalculator.cs (163) : // Build result dictionary
DistanceCalculator.cs (164) : HashTableDictionary<string, double> result = new HashTableDictionary<string, double>();
DistanceCalculator.cs (165) : for (int i = 0; i < n; i++)
DistanceCalculator.cs (166) : result.Add(elements[i], dist[i]);
DistanceCalculator.cs (168) : return result;
GenericList.cs (1) : using System.Collections;
GenericList.cs (3) : namespace ListsStacksAndQueues
GenericList.cs (4) : {
GenericList.cs (6) : public class GenericListNode<T>
GenericList.cs (7) : {
GenericList.cs (8) : public T Value;
GenericList.cs (9) : public GenericListNode<T> Next = null;
GenericList.cs (11) : public GenericListNode(T value)
GenericList.cs (12) : {
GenericList.cs (13) : Value = value;
GenericList.cs (14) : }
GenericList.cs (16) : public override string ToString()
GenericList.cs (17) : {
GenericList.cs (18) : return Value.ToString();
GenericList.cs (19) : }
GenericList.cs (20) : }
GenericList.cs (22) : public class GenericList<T> : IGenericList<T>
GenericList.cs (23) : {
GenericList.cs (24) : GenericListNode<T> First = null;
GenericList.cs (25) : GenericListNode<T> Last = null;
GenericList.cs (27) : public override string ToString()
GenericList.cs (28) : {
GenericList.cs (29) : GenericListNode<T> node = First;
GenericList.cs (30) : string output = "[";
GenericList.cs (32) : while (node != null)
GenericList.cs (33) : {
GenericList.cs (34) : output += node.ToString() + ",";
GenericList.cs (35) : node = node.Next;
GenericList.cs (36) : }
GenericList.cs (37) : output = output.TrimEnd(',') + "] " + Count() + " elements";
GenericList.cs (39) : return output;
GenericList.cs (40) : }
GenericList.cs (42) : public void Add(T value)
GenericList.cs (43) : {
GenericList.cs (44) : //TODO #1: add a new element to the end of the list
GenericList.cs (45) : GenericListNode<T> nodo = First;
GenericList.cs (46) : if (nodo == null)
GenericList.cs (47) : {
GenericList.cs (48) : First = new GenericListNode<T>(value);
GenericList.cs (49) : Last = new GenericListNode<T>(value);
GenericList.cs (50) : }
GenericList.cs (51) : else
GenericList.cs (52) : {
GenericList.cs (53) : while (nodo.Next != null)
GenericList.cs (54) : {
GenericList.cs (55) : nodo = nodo.Next;
GenericList.cs (56) : }
GenericList.cs (57) : Last = new GenericListNode<T>(value);
GenericList.cs (58) : nodo.Next = Last;
GenericList.cs (59) : }
GenericList.cs (60) : }
GenericList.cs (62) : public T Get(int index) //QUE ES FINDNOTE(int)********************************************
GenericList.cs (63) : {
GenericList.cs (64) : //TODO #2: return the element on the index-th position. YOU MUST USE FindNode(int). Return the default value for object class T if the position is out of bounds
GenericList.cs (67) : GenericListNode<T> nodo = First;
GenericList.cs (68) : if (nodo == null)
GenericList.cs (69) : {
GenericList.cs (70) : return default(T);
GenericList.cs (71) : }
GenericList.cs (72) : for (int i = 1; i <= index; i++)
GenericList.cs (73) : {
GenericList.cs (74) : if (nodo.Next != null)
GenericList.cs (75) : {
GenericList.cs (76) : nodo = nodo.Next;
GenericList.cs (77) : }
GenericList.cs (78) : else
GenericList.cs (79) : {
GenericList.cs (80) : return default(T);
GenericList.cs (81) : }
GenericList.cs (84) : }
GenericList.cs (86) : return nodo.Value;
GenericList.cs (87) : }
GenericList.cs (88) : public int Count()
GenericList.cs (89) : {
GenericList.cs (90) : //TODO #3: return the number of elements on the list
GenericList.cs (92) : GenericListNode<T> nodo = First;
GenericList.cs (93) : int count = 0;
GenericList.cs (94) : if (nodo == null)
GenericList.cs (95) : {
GenericList.cs (96) : return count;
GenericList.cs (97) : }
GenericList.cs (98) : else
GenericList.cs (99) : {
GenericList.cs (100) : count++;
GenericList.cs (101) : while (nodo.Next != null)
GenericList.cs (102) : {
GenericList.cs (103) : nodo = nodo.Next;
GenericList.cs (104) : count++;
GenericList.cs (106) : }
GenericList.cs (107) : return count;
GenericList.cs (108) : }
GenericList.cs (109) : }
GenericList.cs (112) : public void Remove(int index)
GenericList.cs (113) : {
GenericList.cs (114) : //TODO #4: remove the element on the index-th position. Do nothing if position is out of bounds
GenericList.cs (115) : GenericListNode<T> nodo = First, anterior = null;
GenericList.cs (116) : if (index == 0)
GenericList.cs (117) : {
GenericList.cs (118) : First = First.Next;
GenericList.cs (119) : return;
GenericList.cs (120) : }
GenericList.cs (121) : if (First != null)
GenericList.cs (122) : {
GenericList.cs (123) : for (int i = 1; i <= index; i++)
GenericList.cs (124) : {
GenericList.cs (125) : if (nodo.Next != null)
GenericList.cs (126) : {
GenericList.cs (127) : anterior = nodo;
GenericList.cs (128) : nodo = nodo.Next;
GenericList.cs (129) : }
GenericList.cs (130) : else
GenericList.cs (131) : {
GenericList.cs (132) : return;
GenericList.cs (133) : }
GenericList.cs (134) : }
GenericList.cs (135) : anterior.Next = nodo.Next;
GenericList.cs (136) : }
GenericList.cs (137) : }
GenericList.cs (139) : public void Clear()
GenericList.cs (140) : {
GenericList.cs (141) : //TODO #5: remove all the elements on the list
GenericList.cs (142) : First = null;
GenericList.cs (143) : }
GenericList.cs (144) : public IEnumerator GetEnumerator()
GenericList.cs (145) : {
GenericList.cs (146) : //TODO #6: return all items one by one using "yield return ..."
GenericList.cs (147) : GenericListNode<T> nodo = First;
GenericList.cs (148) : while (nodo != null)
GenericList.cs (149) : {
GenericList.cs (150) : yield return nodo.Value;
GenericList.cs (151) : nodo = nodo.Next;
GenericList.cs (153) : }
GenericList.cs (154) : }
GenericList.cs (155) : }
GenericList.cs (156) : }
GraphReaderWriter.cs (12) : str = str.Replace("->", "[FLECHA]");
GraphReaderWriter.cs (13) : return str.Replace("\n", "[NEW_LINE]");
GraphReaderWriter.cs (20) : str = str.Replace("[FLECHA]","->");
GraphReaderWriter.cs (21) : return str.Replace("[NEW_LINE]", "\n");
GraphReaderWriter.cs (33) : TKey[] tablaElementos = graph.Elements();
GraphReaderWriter.cs (34) : String temp;
GraphReaderWriter.cs (35) : for(int i = 0; i<tablaElementos.Length; i++)
GraphReaderWriter.cs (36) : {
GraphReaderWriter.cs (37) : writer.WriteLine(EncodeString(keyToString(tablaElementos[i])));
GraphReaderWriter.cs (38) : }
GraphReaderWriter.cs (39) : writer.WriteLine("");
GraphReaderWriter.cs (40) : for (int i = 0; i < tablaElementos.Length; i++)
GraphReaderWriter.cs (41) : {
GraphReaderWriter.cs (42) : Vertex<TKey, TWeight> actual = graph.GetVertex(tablaElementos[i]);
GraphReaderWriter.cs (43) : TKey[] ConnElements = actual.ConnectedElements();
GraphReaderWriter.cs (44) : for (int j = 0; j<ConnElements.Length;j++)
GraphReaderWriter.cs (45) : {
GraphReaderWriter.cs (46) : writer.WriteLine(EncodeString(keyToString(tablaElementos[i])) + "->" + EncodeString(weightToString(actual.GetEdgeWeight(ConnElements[j]))) + "->" + EncodeString(keyToString(ConnElements[j])));
GraphReaderWriter.cs (47) : }
GraphReaderWriter.cs (48) : }
GraphReaderWriter.cs (70) : Boolean found = false;
GraphReaderWriter.cs (71) : String temp;
GraphReaderWriter.cs (72) : while(!found)
GraphReaderWriter.cs (73) : {
GraphReaderWriter.cs (74) : temp = reader.ReadLine();
GraphReaderWriter.cs (76) : if (temp == "")
GraphReaderWriter.cs (77) : {
GraphReaderWriter.cs (78) : found = true;
GraphReaderWriter.cs (79) : }
GraphReaderWriter.cs (80) : else
GraphReaderWriter.cs (81) : {
GraphReaderWriter.cs (82) : graph.AddVertex(stringToKey(DecodeString(temp)));
GraphReaderWriter.cs (83) : }
GraphReaderWriter.cs (84) : }
GraphReaderWriter.cs (85) : found = false;
GraphReaderWriter.cs (86) : String[] linea;
GraphReaderWriter.cs (87) : while (!found)
GraphReaderWriter.cs (88) : {
GraphReaderWriter.cs (89) : temp=reader.ReadLine();
GraphReaderWriter.cs (90) : if (temp != null)
GraphReaderWriter.cs (91) : {
GraphReaderWriter.cs (92) : linea = temp.Split("->");
GraphReaderWriter.cs (93) : graph.AddEdge(stringToKey(DecodeString(linea[0])), stringToKey(DecodeString(linea[2])), stringToWeight(DecodeString(linea[1])));
GraphReaderWriter.cs (94) : }
GraphReaderWriter.cs (95) : else
GraphReaderWriter.cs (96) : {
GraphReaderWriter.cs (97) : found = true;
GraphReaderWriter.cs (98) : }
GraphReaderWriter.cs (99) : }
HashTableDictionary.cs (1) : using Common;
HashTableDictionary.cs (2) : using ListsStacksAndQueues;
HashTableDictionary.cs (3) : using System;
HashTableDictionary.cs (5) : public class HashTableDictionaryItem<TKey, TValue>
HashTableDictionary.cs (6) : {
HashTableDictionary.cs (7) : public TKey Key;
HashTableDictionary.cs (8) : public TValue Value;
HashTableDictionary.cs (10) : public HashTableDictionaryItem(TKey key, TValue value)
HashTableDictionary.cs (11) : {
HashTableDictionary.cs (12) : Key = key;
HashTableDictionary.cs (13) : Value = value;
HashTableDictionary.cs (14) : }
HashTableDictionary.cs (16) : public override string ToString()
HashTableDictionary.cs (17) : {
HashTableDictionary.cs (18) : if (!Key.Equals(default(TKey)))
HashTableDictionary.cs (19) : return $"[{Key}->{Value}]\n";
HashTableDictionary.cs (20) : else
HashTableDictionary.cs (21) : return null;
HashTableDictionary.cs (22) : }
HashTableDictionary.cs (23) : }
HashTableDictionary.cs (25) : public class HashTableDictionary<TKey, TValue> : IDictionary<TKey, TValue>
HashTableDictionary.cs (26) : {
HashTableDictionary.cs (27) : int NumElements = 0;
HashTableDictionary.cs (28) : //TODO #1: Copy your implementation of GenericList to the project HashTableDictionary and use it to declare Entries: an array of lists of HashTableDictionaryItem<TKey,TValue>
HashTableDictionary.cs (29) : //[USE GenericList and HashTableDictionaryItem[] Entries;
HashTableDictionary.cs (30) : GenericList<HashTableDictionaryItem<TKey, TValue>>[] Entries;
HashTableDictionary.cs (32) : public HashTableDictionary() : this(10000)
HashTableDictionary.cs (33) : {
HashTableDictionary.cs (34) : //This constructor just calls the constructor below with a default value maxSize=10000
HashTableDictionary.cs (35) : //No need to do anything here
HashTableDictionary.cs (36) : }
HashTableDictionary.cs (38) : public HashTableDictionary(int maxSize)
HashTableDictionary.cs (39) : {
HashTableDictionary.cs (40) : //TODO #2: Initialize Entries with an array of size maxSize
HashTableDictionary.cs (41) : Entries = new GenericList<HashTableDictionaryItem<TKey, TValue>>[maxSize];
HashTableDictionary.cs (42) : }
HashTableDictionary.cs (44) : public override string ToString()
HashTableDictionary.cs (45) : {
HashTableDictionary.cs (46) : string output = null;
HashTableDictionary.cs (48) : //TODO #3: Uncomment this
HashTableDictionary.cs (50) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (51) : {
HashTableDictionary.cs (52) : if (Entries[i] != null)
HashTableDictionary.cs (53) : {
HashTableDictionary.cs (54) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (55) : {
HashTableDictionary.cs (56) : HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (57) : output += entry.ToString();
HashTableDictionary.cs (58) : }
HashTableDictionary.cs (59) : }
HashTableDictionary.cs (60) : }
HashTableDictionary.cs (62) : return output;
HashTableDictionary.cs (63) : }
HashTableDictionary.cs (65) : public int Count()
HashTableDictionary.cs (66) : {
HashTableDictionary.cs (67) : //TODO #4: Return the number of elements (NumElements: make sure this member variable/attribute is updated when the number of elements changes)
HashTableDictionary.cs (69) : /* int count = 0;
HashTableDictionary.cs (70) : if (Entries == null) { return 0; }
HashTableDictionary.cs (71) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (72) : {
HashTableDictionary.cs (73) : if (Entries[i] != null)
HashTableDictionary.cs (74) : {
HashTableDictionary.cs (75) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (76) : {
HashTableDictionary.cs (77) : if (Entries[i] != null)
HashTableDictionary.cs (78) : {
HashTableDictionary.cs (79) : count++;
HashTableDictionary.cs (80) : }
HashTableDictionary.cs (81) : }
HashTableDictionary.cs (82) : }
HashTableDictionary.cs (84) : }
HashTableDictionary.cs (85) : */
HashTableDictionary.cs (86) : return NumElements;
HashTableDictionary.cs (87) : }
HashTableDictionary.cs (89) : public int FindKey(TKey key)
HashTableDictionary.cs (90) : {
HashTableDictionary.cs (91) : //TODO #4:  Calculate in which entry should this key be stored and return it (use key.GetHashCode() to calculate the hash function of the key)
HashTableDictionary.cs (92) : //          Note:  GetHashCode() returns very large integer numbers, but we need to map this value to the range [0, Entries.Length-1]
HashTableDictionary.cs (94) : int keyHash = key.GetHashCode();
HashTableDictionary.cs (95) : return Math.Abs(keyHash % (Entries.Length - 1));
HashTableDictionary.cs (96) : }
HashTableDictionary.cs (98) : public TValue Get(TKey key)
HashTableDictionary.cs (99) : {
HashTableDictionary.cs (100) : //TODO #5:  Using FindKey, calculate where this key should be in the array of entries. Then, find the item with this key on the list, and return its value
HashTableDictionary.cs (102) : int KeyFound = FindKey(key);
HashTableDictionary.cs (103) : if (Entries[KeyFound] != null)
HashTableDictionary.cs (104) : {
HashTableDictionary.cs (107) : for (int i = 0; i < Entries[KeyFound].Count(); i++)
HashTableDictionary.cs (108) : {
HashTableDictionary.cs (109) : if (Entries[KeyFound].Get(i).Key.Equals(key))
HashTableDictionary.cs (110) : {
HashTableDictionary.cs (111) : return Entries[KeyFound].Get(i).Value;
HashTableDictionary.cs (112) : }
HashTableDictionary.cs (114) : }
HashTableDictionary.cs (115) : }
HashTableDictionary.cs (116) : return default;
HashTableDictionary.cs (117) : }
HashTableDictionary.cs (119) : public void Add(TKey key, TValue value)
HashTableDictionary.cs (120) : {
HashTableDictionary.cs (121) : //TODO #5:  Using FindKey, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (122) : //          If the item is not found, add a new item to the list with the given key/value
HashTableDictionary.cs (123) : //          If the item is found, just update its value
HashTableDictionary.cs (124) : int KeyFound = FindKey(key);
HashTableDictionary.cs (125) : TValue valor = default;
HashTableDictionary.cs (127) : if (Entries[KeyFound] == null)
HashTableDictionary.cs (128) : {
HashTableDictionary.cs (129) : Entries[KeyFound] = new GenericList<HashTableDictionaryItem<TKey, TValue>>();
HashTableDictionary.cs (130) : // Entries[KeyFound].Add(new HashTableDictionaryItem < TKey, TValue >(key, value));
HashTableDictionary.cs (131) : }
HashTableDictionary.cs (133) : for (int i = 0; i < Entries[KeyFound].Count(); i++)
HashTableDictionary.cs (134) : {
HashTableDictionary.cs (135) : if (Entries[KeyFound].Get(i).Key.Equals(key))
HashTableDictionary.cs (136) : {
HashTableDictionary.cs (137) : Entries[KeyFound].Get(i).Value = value;
HashTableDictionary.cs (138) : return;
HashTableDictionary.cs (139) : }
HashTableDictionary.cs (140) : }
HashTableDictionary.cs (141) : Entries[KeyFound].Add(new HashTableDictionaryItem<TKey, TValue>(key, value));
HashTableDictionary.cs (142) : NumElements++;
HashTableDictionary.cs (143) : }
HashTableDictionary.cs (145) : public void Remove(TKey key)
HashTableDictionary.cs (146) : {
HashTableDictionary.cs (147) : //TODO #6: Using FindKey, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (148) : //          If the item is not found, do nothing
HashTableDictionary.cs (149) : //          If the item is found, remove it from the list and return
HashTableDictionary.cs (150) : int KeyFound = FindKey(key);
HashTableDictionary.cs (151) : if (Entries[KeyFound] != null)
HashTableDictionary.cs (152) : {
HashTableDictionary.cs (153) : for (int i = 0; i < Entries[KeyFound].Count(); i++)
HashTableDictionary.cs (154) : {
HashTableDictionary.cs (155) : if (Entries[KeyFound].Get(i).Key.Equals(key))
HashTableDictionary.cs (156) : {
HashTableDictionary.cs (157) : Entries[KeyFound].Remove(i);
HashTableDictionary.cs (158) : NumElements--;
HashTableDictionary.cs (159) : return;
HashTableDictionary.cs (160) : }
HashTableDictionary.cs (161) : }
HashTableDictionary.cs (162) : }
HashTableDictionary.cs (163) : }
HashTableDictionary.cs (165) : public TKey[] Keys()
HashTableDictionary.cs (166) : {
HashTableDictionary.cs (167) : //TODO #8: Return all the keys (not necessarily ordered) in an array
HashTableDictionary.cs (168) : int count = 0;
HashTableDictionary.cs (169) : TKey[] keys;
HashTableDictionary.cs (170) : if (Entries == null) { return null; }
HashTableDictionary.cs (171) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (172) : {
HashTableDictionary.cs (173) : if (Entries[i] != null)
HashTableDictionary.cs (174) : {
HashTableDictionary.cs (175) : count = count + Entries[i].Count();
HashTableDictionary.cs (176) : }
HashTableDictionary.cs (177) : }
HashTableDictionary.cs (178) : keys = new TKey[count];
HashTableDictionary.cs (179) : int num = 0;
HashTableDictionary.cs (180) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (181) : {
HashTableDictionary.cs (182) : if (Entries[i] != null)
HashTableDictionary.cs (183) : {
HashTableDictionary.cs (184) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (185) : {
HashTableDictionary.cs (186) : keys[num] = Entries[i].Get(j).Key;
HashTableDictionary.cs (187) : num++;
HashTableDictionary.cs (188) : }
HashTableDictionary.cs (189) : }
HashTableDictionary.cs (191) : }
HashTableDictionary.cs (192) : return keys;
HashTableDictionary.cs (193) : }
HashTableDictionary.cs (195) : public TValue[] Values()
HashTableDictionary.cs (196) : {
HashTableDictionary.cs (197) : //TODO #9: Return all the values (in the same order as the keys) in an array
HashTableDictionary.cs (198) : int count = 0;
HashTableDictionary.cs (199) : TValue[] values;
HashTableDictionary.cs (200) : if (Entries == null) { return null; }
HashTableDictionary.cs (201) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (202) : {
HashTableDictionary.cs (203) : if (Entries[i] != null)
HashTableDictionary.cs (204) : {
HashTableDictionary.cs (205) : count = count + Entries[i].Count();
HashTableDictionary.cs (206) : }
HashTableDictionary.cs (207) : }
HashTableDictionary.cs (208) : values = new TValue[count];
HashTableDictionary.cs (209) : int num = 0;
HashTableDictionary.cs (210) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (211) : {
HashTableDictionary.cs (212) : if (Entries[i] != null)
HashTableDictionary.cs (213) : {
HashTableDictionary.cs (214) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (215) : {
HashTableDictionary.cs (216) : values[num] = Entries[i].Get(j).Value;
HashTableDictionary.cs (217) : num++;
HashTableDictionary.cs (218) : }
HashTableDictionary.cs (219) : }
HashTableDictionary.cs (221) : }
HashTableDictionary.cs (222) : return values;
HashTableDictionary.cs (223) : }
HashTableDictionary.cs (224) : }
IGenericList.cs (1) : using System;
IGenericList.cs (2) : using System.Collections;
IGenericList.cs (3) : using System.Collections.Generic;
IGenericList.cs (4) : using System.Linq;
IGenericList.cs (5) : using System.Text;
IGenericList.cs (6) : using System.Threading.Tasks;
IGenericList.cs (8) : namespace ListsStacksAndQueues
IGenericList.cs (9) : {
IGenericList.cs (10) : public interface IGenericList<T> : IEnumerable
IGenericList.cs (11) : {
IGenericList.cs (12) : int Count();
IGenericList.cs (14) : T Get(int index);
IGenericList.cs (16) : void Add(T value);
IGenericList.cs (18) : void Remove(int index);
IGenericList.cs (20) : void Clear();
IGenericList.cs (21) : }
IGenericList.cs (22) : }
UnDirectedGraph.cs (4) : using Common;
UnDirectedGraph.cs (12) : protected HashTableDictionary<TElement, Vertex<TElement, TWeight>> Vertices = new HashTableDictionary<TElement, Vertex<TElement, TWeight>>();
UnDirectedGraph.cs (19) : Vertex<TElement, TWeight>[] vertices = Vertices.Values();
UnDirectedGraph.cs (20) : for (int i = 0; i <= Vertices.Count() - 1; i++)
UnDirectedGraph.cs (21) : {
UnDirectedGraph.cs (22) : output = output + vertices[i].ToString() + "\n";
UnDirectedGraph.cs (24) : }
UnDirectedGraph.cs (34) : return Vertices.Keys(); ;
UnDirectedGraph.cs (41) : Vertices.Add(element, new Vertex<TElement, TWeight>(element));
UnDirectedGraph.cs (47) : Vertices.Get(source).AddEdge(destination, weight);
UnDirectedGraph.cs (48) : Vertices.Get(destination).AddEdge(source, weight);
UnDirectedGraph.cs (55) : return Vertices.Count();
UnDirectedGraph.cs (56) : }
UnDirectedGraph.cs (61) : int EdgeCount = 0;
UnDirectedGraph.cs (62) : Vertex<TElement, TWeight>[] vertices = Vertices.Values();
UnDirectedGraph.cs (63) : for (int i = 0; i < vertices.Length; i++)
UnDirectedGraph.cs (64) : {
UnDirectedGraph.cs (65) : EdgeCount += vertices[i].EdgeCount();
UnDirectedGraph.cs (66) : }
UnDirectedGraph.cs (67) : return EdgeCount;
UnDirectedGraph.cs (73) : Vertex<TElement, TWeight> VSource = Vertices.Get(source);
UnDirectedGraph.cs (74) : Vertex<TElement, TWeight> VDestination = Vertices.Get(destination);
UnDirectedGraph.cs (76) : if (VSource != null && VDestination != null)
UnDirectedGraph.cs (77) : {
UnDirectedGraph.cs (78) : return VSource.GetEdgeWeight(VDestination.Element);
UnDirectedGraph.cs (79) : }
UnDirectedGraph.cs (86) : if (Vertices != null)
UnDirectedGraph.cs (87) : {
UnDirectedGraph.cs (88) : Vertex<TElement, TWeight> sourceVertex = Vertices.Get(source);
UnDirectedGraph.cs (89) : if (sourceVertex != null)
UnDirectedGraph.cs (90) : sourceVertex.RemoveEdge(destination);
UnDirectedGraph.cs (92) : Vertex<TElement, TWeight> destVertex = Vertices.Get(destination);
UnDirectedGraph.cs (93) : if (destVertex != null)
UnDirectedGraph.cs (94) : destVertex.RemoveEdge(source);
UnDirectedGraph.cs (95) : }
UnDirectedGraph.cs (101) : Vertex<TElement, TWeight> actual = Vertices.Get(element);
UnDirectedGraph.cs (102) : TElement[] tabla = actual.ConnectedElements();
UnDirectedGraph.cs (103) : for(int i = 0; i < tabla.Length; i++)
UnDirectedGraph.cs (104) : {
UnDirectedGraph.cs (105) : Vertices.Get(element).RemoveEdge(tabla[i]);
UnDirectedGraph.cs (106) : Vertices.Get(tabla[i]).RemoveEdge(element);
UnDirectedGraph.cs (107) : }
UnDirectedGraph.cs (108) : Vertices.Remove(element);
UnDirectedGraph.cs (115) : return Vertices.Get(element);
Vertex.cs (8) : public HashTableDictionary<TElement, TWeight> Edges = new HashTableDictionary<TElement, TWeight>();
Vertex.cs (9) : // Keep track of incoming edges (sources that point to this vertex)
Vertex.cs (10) : public HashTableDictionary<TElement, bool> Incoming = new HashTableDictionary<TElement, bool>();
Vertex.cs (11) : // Maintain a compact list of outgoing targets for iteration performance
Vertex.cs (12) : public System.Collections.Generic.List<TElement> targets = new System.Collections.Generic.List<TElement>();
Vertex.cs (18) : this.targets = new System.Collections.Generic.List<TElement>();
Vertex.cs (23) : // Return the target vertices of the edges starting from this vertex using the compact list
Vertex.cs (24) : return targets.ToArray();
Vertex.cs (25) : }
Vertex.cs (27) : public TElement[] IncomingElements()
Vertex.cs (28) : {
Vertex.cs (29) : return Incoming.Keys();
Vertex.cs (30) : }
Vertex.cs (32) : public void AddIncoming(TElement sourceElement)
Vertex.cs (33) : {
Vertex.cs (34) : // Only add if not already present
Vertex.cs (35) : try
Vertex.cs (36) : {
Vertex.cs (37) : Incoming.Add(sourceElement, true);
Vertex.cs (38) : }
Vertex.cs (39) : catch (Exception)
Vertex.cs (40) : {
Vertex.cs (41) : // Ignore if already present
Vertex.cs (42) : }
Vertex.cs (43) : }
Vertex.cs (45) : public void RemoveIncoming(TElement sourceElement)
Vertex.cs (46) : {
Vertex.cs (47) : Incoming.Remove(sourceElement);
Vertex.cs (52) : // Add or update edge weight
Vertex.cs (53) : Edges.Add(targetElement, weight);
Vertex.cs (54) : // Ensure target is in compact list
Vertex.cs (55) : bool found = false;
Vertex.cs (56) : for (int i = 0; i < targets.Count; i++)
Vertex.cs (57) : {
Vertex.cs (58) : if (targets[i].Equals(targetElement))
Vertex.cs (59) : {
Vertex.cs (60) : found = true; break;
Vertex.cs (61) : }
Vertex.cs (62) : }
Vertex.cs (63) : if (!found)
Vertex.cs (64) : targets.Add(targetElement);
Vertex.cs (69) : // Return number of outgoing edges (use compact list)
Vertex.cs (70) : return targets.Count;
Vertex.cs (75) : // Remove from dictionary and compact list
Vertex.cs (76) : Edges.Remove(targetElement);
Vertex.cs (77) : for (int i = 0; i < targets.Count; i++)
Vertex.cs (79) : if (targets[i].Equals(targetElement))
Vertex.cs (81) : targets.RemoveAt(i);
Vertex.cs (82) : break;
Vertex.cs (83) : }
Vertex.cs (87) : public TWeight GetEdgeWeight(TElement targetElement)
Vertex.cs (88) : {
Vertex.cs (89) : // Return the stored weight or default if no edge exists
Vertex.cs (90) : return Edges.Get(targetElement);
Vertex.cs (100) : string output = "";
Vertex.cs (101) : TElement[] elements = Edges.Keys();
Vertex.cs (102) : TWeight[] pesos = Edges.Values();
Vertex.cs (104) : for(int i=0; i < elements.Length; i++)
Vertex.cs (106) : output = output + Element + "->" + pesos[i] + "->" + elements[i] + "\n";
