DirectedGraph.cs (9) : Vertices.Get(sourceKey).AddEdge(destinationKey, weight);
DirectedGraph.cs (16) : TElement[] tablaVertices = Vertices.Keys();
DirectedGraph.cs (17) : for (int i = 0; i<tablaVertices.Length; i++)
DirectedGraph.cs (18) : {
DirectedGraph.cs (19) : Vertices.Get(element).RemoveEdge(tablaVertices[i]);
DirectedGraph.cs (20) : Vertices.Get(tablaVertices[i]).RemoveEdge(element);
DirectedGraph.cs (21) : }
DirectedGraph.cs (22) : Vertices.Remove(element);
DirectedGraph.cs (28) : Vertices.Get(sourceKey).RemoveEdge(destKey);
DistanceCalculator.cs (8) : public UndirectedGraph<String, double> ciudades = new UndirectedGraph<String, double>();
DistanceCalculator.cs (12) : if (isUndirected)
DistanceCalculator.cs (13) : {
DistanceCalculator.cs (14) : ciudades = new UndirectedGraph<String, double>();
DistanceCalculator.cs (15) : }
DistanceCalculator.cs (16) : else
DistanceCalculator.cs (17) : {
DistanceCalculator.cs (18) : ciudades = new DirectedGraph<String, double>();
DistanceCalculator.cs (19) : }
DistanceCalculator.cs (25) : ciudades.AddVertex(city);
DistanceCalculator.cs (31) : ciudades.AddEdge(fromCity, toCity, distance);
DistanceCalculator.cs (61) : HashTableDictionary<string, double> distanceToCity = new HashTableDictionary<string, double>();
DistanceCalculator.cs (62) : HashTableDictionary< string, bool> visited = new HashTableDictionary<string,bool>();
DistanceCalculator.cs (63) : HashTableDictionary<string, double> nextCityCandidates = new HashTableDictionary<string, double>();
DistanceCalculator.cs (64) : String[] elements = ciudades.Elements();
DistanceCalculator.cs (65) : string currentCity;
DistanceCalculator.cs (67) : for (int i = 0; i < elements.Length; i++)
DistanceCalculator.cs (68) : {
DistanceCalculator.cs (69) : if (elements[i] != fromCity)
DistanceCalculator.cs (70) : {
DistanceCalculator.cs (71) : distanceToCity.Add(elements[i], 0);
DistanceCalculator.cs (72) : visited.Add(elements[i], false);
DistanceCalculator.cs (73) : nextCityCandidates.Add(elements[i], 0);
DistanceCalculator.cs (74) : }
DistanceCalculator.cs (75) : }
DistanceCalculator.cs (77) : currentCity = elements[0];
DistanceCalculator.cs (78) : while (currentCity != null)
DistanceCalculator.cs (79) : {
DistanceCalculator.cs (80) : CheckNeighbours(distanceToCity, visited, nextCityCandidates, currentCity);
DistanceCalculator.cs (81) : //papa a dicho que no sigamos, vamos a hacer el examen de prueba, por favor y gracias
DistanceCalculator.cs (82) : }
GenericList.cs (1) : using System.Collections;
GenericList.cs (3) : namespace ListsStacksAndQueues
GenericList.cs (4) : {
GenericList.cs (6) : public class GenericListNode<T>
GenericList.cs (7) : {
GenericList.cs (8) : public T Value;
GenericList.cs (9) : public GenericListNode<T> Next = null;
GenericList.cs (11) : public GenericListNode(T value)
GenericList.cs (12) : {
GenericList.cs (13) : Value = value;
GenericList.cs (14) : }
GenericList.cs (16) : public override string ToString()
GenericList.cs (17) : {
GenericList.cs (18) : return Value.ToString();
GenericList.cs (19) : }
GenericList.cs (20) : }
GenericList.cs (22) : public class GenericList<T> : IGenericList<T>
GenericList.cs (23) : {
GenericList.cs (24) : GenericListNode<T> First = null;
GenericList.cs (25) : GenericListNode<T> Last = null;
GenericList.cs (27) : public override string ToString()
GenericList.cs (28) : {
GenericList.cs (29) : GenericListNode<T> node = First;
GenericList.cs (30) : string output = "[";
GenericList.cs (32) : while (node != null)
GenericList.cs (33) : {
GenericList.cs (34) : output += node.ToString() + ",";
GenericList.cs (35) : node = node.Next;
GenericList.cs (36) : }
GenericList.cs (37) : output = output.TrimEnd(',') + "] " + Count() + " elements";
GenericList.cs (39) : return output;
GenericList.cs (40) : }
GenericList.cs (42) : public void Add(T value)
GenericList.cs (43) : {
GenericList.cs (44) : //TODO #1: add a new element to the end of the list
GenericList.cs (45) : GenericListNode<T> nodo = First;
GenericList.cs (46) : if (nodo == null)
GenericList.cs (47) : {
GenericList.cs (48) : First = new GenericListNode<T>(value);
GenericList.cs (49) : Last = new GenericListNode<T>(value);
GenericList.cs (50) : }
GenericList.cs (51) : else
GenericList.cs (52) : {
GenericList.cs (53) : while (nodo.Next != null)
GenericList.cs (54) : {
GenericList.cs (55) : nodo = nodo.Next;
GenericList.cs (56) : }
GenericList.cs (57) : Last = new GenericListNode<T>(value);
GenericList.cs (58) : nodo.Next = Last;
GenericList.cs (59) : }
GenericList.cs (60) : }
GenericList.cs (62) : public T Get(int index) //QUE ES FINDNOTE(int)********************************************
GenericList.cs (63) : {
GenericList.cs (64) : //TODO #2: return the element on the index-th position. YOU MUST USE FindNode(int). Return the default value for object class T if the position is out of bounds
GenericList.cs (67) : GenericListNode<T> nodo = First;
GenericList.cs (68) : if (nodo == null)
GenericList.cs (69) : {
GenericList.cs (70) : return default(T);
GenericList.cs (71) : }
GenericList.cs (72) : for (int i = 1; i <= index; i++)
GenericList.cs (73) : {
GenericList.cs (74) : if (nodo.Next != null)
GenericList.cs (75) : {
GenericList.cs (76) : nodo = nodo.Next;
GenericList.cs (77) : }
GenericList.cs (78) : else
GenericList.cs (79) : {
GenericList.cs (80) : return default(T);
GenericList.cs (81) : }
GenericList.cs (84) : }
GenericList.cs (86) : return nodo.Value;
GenericList.cs (87) : }
GenericList.cs (88) : public int Count()
GenericList.cs (89) : {
GenericList.cs (90) : //TODO #3: return the number of elements on the list
GenericList.cs (92) : GenericListNode<T> nodo = First;
GenericList.cs (93) : int count = 0;
GenericList.cs (94) : if (nodo == null)
GenericList.cs (95) : {
GenericList.cs (96) : return count;
GenericList.cs (97) : }
GenericList.cs (98) : else
GenericList.cs (99) : {
GenericList.cs (100) : count++;
GenericList.cs (101) : while (nodo.Next != null)
GenericList.cs (102) : {
GenericList.cs (103) : nodo = nodo.Next;
GenericList.cs (104) : count++;
GenericList.cs (106) : }
GenericList.cs (107) : return count;
GenericList.cs (108) : }
GenericList.cs (109) : }
GenericList.cs (112) : public void Remove(int index)
GenericList.cs (113) : {
GenericList.cs (114) : //TODO #4: remove the element on the index-th position. Do nothing if position is out of bounds
GenericList.cs (115) : GenericListNode<T> nodo = First, anterior = null;
GenericList.cs (116) : if (index == 0)
GenericList.cs (117) : {
GenericList.cs (118) : First = First.Next;
GenericList.cs (119) : return;
GenericList.cs (120) : }
GenericList.cs (121) : if (First != null)
GenericList.cs (122) : {
GenericList.cs (123) : for (int i = 1; i <= index; i++)
GenericList.cs (124) : {
GenericList.cs (125) : if (nodo.Next != null)
GenericList.cs (126) : {
GenericList.cs (127) : anterior = nodo;
GenericList.cs (128) : nodo = nodo.Next;
GenericList.cs (129) : }
GenericList.cs (130) : else
GenericList.cs (131) : {
GenericList.cs (132) : return;
GenericList.cs (133) : }
GenericList.cs (134) : }
GenericList.cs (135) : anterior.Next = nodo.Next;
GenericList.cs (136) : }
GenericList.cs (137) : }
GenericList.cs (139) : public void Clear()
GenericList.cs (140) : {
GenericList.cs (141) : //TODO #5: remove all the elements on the list
GenericList.cs (142) : First = null;
GenericList.cs (143) : }
GenericList.cs (144) : public IEnumerator GetEnumerator()
GenericList.cs (145) : {
GenericList.cs (146) : //TODO #6: return all items one by one using "yield return ..."
GenericList.cs (147) : GenericListNode<T> nodo = First;
GenericList.cs (148) : while (nodo != null)
GenericList.cs (149) : {
GenericList.cs (150) : yield return nodo.Value;
GenericList.cs (151) : nodo = nodo.Next;
GenericList.cs (153) : }
GenericList.cs (154) : }
GenericList.cs (155) : }
GenericList.cs (156) : }
GraphReaderWriter.cs (12) : str = str.Replace("->", "[FLECHA]");
GraphReaderWriter.cs (13) : return str.Replace("\n", "[NEW_LINE]");
GraphReaderWriter.cs (20) : str = str.Replace("[FLECHA]","->");
GraphReaderWriter.cs (21) : return str.Replace("[NEW_LINE]", "\n");
GraphReaderWriter.cs (33) : TKey[] tablaElementos = graph.Elements();
GraphReaderWriter.cs (34) : String temp;
GraphReaderWriter.cs (35) : for(int i = 0; i<tablaElementos.Length; i++)
GraphReaderWriter.cs (36) : {
GraphReaderWriter.cs (37) : writer.WriteLine(EncodeString(keyToString(tablaElementos[i])));
GraphReaderWriter.cs (38) : }
GraphReaderWriter.cs (39) : writer.WriteLine("");
GraphReaderWriter.cs (40) : for (int i = 0; i < tablaElementos.Length; i++)
GraphReaderWriter.cs (41) : {
GraphReaderWriter.cs (42) : Vertex<TKey, TWeight> actual = graph.GetVertex(tablaElementos[i]);
GraphReaderWriter.cs (43) : TKey[] ConnElements = actual.ConnectedElements();
GraphReaderWriter.cs (44) : for (int j = 0; j<ConnElements.Length;j++)
GraphReaderWriter.cs (45) : {
GraphReaderWriter.cs (46) : writer.WriteLine(EncodeString(keyToString(tablaElementos[i])) + "->" + EncodeString(weightToString(actual.GetEdgeWeight(ConnElements[j]))) + "->" + EncodeString(keyToString(ConnElements[j])));
GraphReaderWriter.cs (47) : }
GraphReaderWriter.cs (48) : }
GraphReaderWriter.cs (70) : Boolean found = false;
GraphReaderWriter.cs (71) : String temp;
GraphReaderWriter.cs (72) : while(!found)
GraphReaderWriter.cs (73) : {
GraphReaderWriter.cs (74) : temp = reader.ReadLine();
GraphReaderWriter.cs (76) : if (temp == "")
GraphReaderWriter.cs (77) : {
GraphReaderWriter.cs (78) : found = true;
GraphReaderWriter.cs (79) : }
GraphReaderWriter.cs (80) : else
GraphReaderWriter.cs (81) : {
GraphReaderWriter.cs (82) : graph.AddVertex(stringToKey(DecodeString(temp)));
GraphReaderWriter.cs (83) : }
GraphReaderWriter.cs (84) : }
GraphReaderWriter.cs (85) : found = false;
GraphReaderWriter.cs (86) : String[] linea;
GraphReaderWriter.cs (87) : while (!found)
GraphReaderWriter.cs (88) : {
GraphReaderWriter.cs (89) : temp=reader.ReadLine();
GraphReaderWriter.cs (90) : if (temp != null)
GraphReaderWriter.cs (91) : {
GraphReaderWriter.cs (92) : linea = temp.Split("->");
GraphReaderWriter.cs (93) : graph.AddEdge(stringToKey(DecodeString(linea[0])), stringToKey(DecodeString(linea[2])), stringToWeight(DecodeString(linea[1])));
GraphReaderWriter.cs (94) : }
GraphReaderWriter.cs (95) : else
GraphReaderWriter.cs (96) : {
GraphReaderWriter.cs (97) : found = true;
GraphReaderWriter.cs (98) : }
GraphReaderWriter.cs (99) : }
HashTableDictionary.cs (1) : using Common;
HashTableDictionary.cs (2) : using ListsStacksAndQueues;
HashTableDictionary.cs (3) : using System;
HashTableDictionary.cs (5) : public class HashTableDictionaryItem<TKey, TValue>
HashTableDictionary.cs (6) : {
HashTableDictionary.cs (7) : public TKey Key;
HashTableDictionary.cs (8) : public TValue Value;
HashTableDictionary.cs (10) : public HashTableDictionaryItem(TKey key, TValue value)
HashTableDictionary.cs (11) : {
HashTableDictionary.cs (12) : Key = key;
HashTableDictionary.cs (13) : Value = value;
HashTableDictionary.cs (14) : }
HashTableDictionary.cs (16) : public override string ToString()
HashTableDictionary.cs (17) : {
HashTableDictionary.cs (18) : if (!Key.Equals(default(TKey)))
HashTableDictionary.cs (19) : return $"[{Key}->{Value}]\n";
HashTableDictionary.cs (20) : else
HashTableDictionary.cs (21) : return null;
HashTableDictionary.cs (22) : }
HashTableDictionary.cs (23) : }
HashTableDictionary.cs (25) : public class HashTableDictionary<TKey, TValue> : IDictionary<TKey, TValue>
HashTableDictionary.cs (26) : {
HashTableDictionary.cs (27) : int NumElements = 0;
HashTableDictionary.cs (28) : //TODO #1: Copy your implementation of GenericList to the project HashTableDictionary and use it to declare Entries: an array of lists of HashTableDictionaryItem<TKey,TValue>
HashTableDictionary.cs (29) : //[USE GenericList and HashTableDictionaryItem[] Entries;
HashTableDictionary.cs (30) : GenericList<HashTableDictionaryItem<TKey, TValue>>[] Entries;
HashTableDictionary.cs (32) : public HashTableDictionary() : this(10000)
HashTableDictionary.cs (33) : {
HashTableDictionary.cs (34) : //This constructor just calls the constructor below with a default value maxSize=10000
HashTableDictionary.cs (35) : //No need to do anything here
HashTableDictionary.cs (36) : }
HashTableDictionary.cs (38) : public HashTableDictionary(int maxSize)
HashTableDictionary.cs (39) : {
HashTableDictionary.cs (40) : //TODO #2: Initialize Entries with an array of size maxSize
HashTableDictionary.cs (41) : Entries = new GenericList<HashTableDictionaryItem<TKey, TValue>>[maxSize];
HashTableDictionary.cs (42) : }
HashTableDictionary.cs (44) : public override string ToString()
HashTableDictionary.cs (45) : {
HashTableDictionary.cs (46) : string output = null;
HashTableDictionary.cs (48) : //TODO #3: Uncomment this
HashTableDictionary.cs (50) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (51) : {
HashTableDictionary.cs (52) : if (Entries[i] != null)
HashTableDictionary.cs (53) : {
HashTableDictionary.cs (54) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (55) : {
HashTableDictionary.cs (56) : HashTableDictionaryItem<TKey, TValue> entry = Entries[i].Get(j);
HashTableDictionary.cs (57) : output += entry.ToString();
HashTableDictionary.cs (58) : }
HashTableDictionary.cs (59) : }
HashTableDictionary.cs (60) : }
HashTableDictionary.cs (62) : return output;
HashTableDictionary.cs (63) : }
HashTableDictionary.cs (65) : public int Count()
HashTableDictionary.cs (66) : {
HashTableDictionary.cs (67) : //TODO #4: Return the number of elements (NumElements: make sure this member variable/attribute is updated when the number of elements changes)
HashTableDictionary.cs (69) : /* int count = 0;
HashTableDictionary.cs (70) : if (Entries == null) { return 0; }
HashTableDictionary.cs (71) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (72) : {
HashTableDictionary.cs (73) : if (Entries[i] != null)
HashTableDictionary.cs (74) : {
HashTableDictionary.cs (75) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (76) : {
HashTableDictionary.cs (77) : if (Entries[i] != null)
HashTableDictionary.cs (78) : {
HashTableDictionary.cs (79) : count++;
HashTableDictionary.cs (80) : }
HashTableDictionary.cs (81) : }
HashTableDictionary.cs (82) : }
HashTableDictionary.cs (84) : }
HashTableDictionary.cs (85) : */
HashTableDictionary.cs (86) : return NumElements;
HashTableDictionary.cs (87) : }
HashTableDictionary.cs (89) : public int FindKey(TKey key)
HashTableDictionary.cs (90) : {
HashTableDictionary.cs (91) : //TODO #4:  Calculate in which entry should this key be stored and return it (use key.GetHashCode() to calculate the hash function of the key)
HashTableDictionary.cs (92) : //          Note:  GetHashCode() returns very large integer numbers, but we need to map this value to the range [0, Entries.Length-1]
HashTableDictionary.cs (94) : int keyHash = key.GetHashCode();
HashTableDictionary.cs (95) : return Math.Abs(keyHash % (Entries.Length - 1));
HashTableDictionary.cs (96) : }
HashTableDictionary.cs (98) : public TValue Get(TKey key)
HashTableDictionary.cs (99) : {
HashTableDictionary.cs (100) : //TODO #5:  Using FindKey, calculate where this key should be in the array of entries. Then, find the item with this key on the list, and return its value
HashTableDictionary.cs (102) : int KeyFound = FindKey(key);
HashTableDictionary.cs (103) : if (Entries[KeyFound] != null)
HashTableDictionary.cs (104) : {
HashTableDictionary.cs (107) : for (int i = 0; i < Entries[KeyFound].Count(); i++)
HashTableDictionary.cs (108) : {
HashTableDictionary.cs (109) : if (Entries[KeyFound].Get(i).Key.Equals(key))
HashTableDictionary.cs (110) : {
HashTableDictionary.cs (111) : return Entries[KeyFound].Get(i).Value;
HashTableDictionary.cs (112) : }
HashTableDictionary.cs (114) : }
HashTableDictionary.cs (115) : }
HashTableDictionary.cs (116) : return default;
HashTableDictionary.cs (117) : }
HashTableDictionary.cs (119) : public void Add(TKey key, TValue value)
HashTableDictionary.cs (120) : {
HashTableDictionary.cs (121) : //TODO #5:  Using FindKey, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (122) : //          If the item is not found, add a new item to the list with the given key/value
HashTableDictionary.cs (123) : //          If the item is found, just update its value
HashTableDictionary.cs (124) : int KeyFound = FindKey(key);
HashTableDictionary.cs (125) : TValue valor = default;
HashTableDictionary.cs (127) : if (Entries[KeyFound] == null)
HashTableDictionary.cs (128) : {
HashTableDictionary.cs (129) : Entries[KeyFound] = new GenericList<HashTableDictionaryItem<TKey, TValue>>();
HashTableDictionary.cs (130) : // Entries[KeyFound].Add(new HashTableDictionaryItem < TKey, TValue >(key, value));
HashTableDictionary.cs (131) : }
HashTableDictionary.cs (133) : for (int i = 0; i < Entries[KeyFound].Count(); i++)
HashTableDictionary.cs (134) : {
HashTableDictionary.cs (135) : if (Entries[KeyFound].Get(i).Key.Equals(key))
HashTableDictionary.cs (136) : {
HashTableDictionary.cs (137) : Entries[KeyFound].Get(i).Value = value;
HashTableDictionary.cs (138) : return;
HashTableDictionary.cs (139) : }
HashTableDictionary.cs (140) : }
HashTableDictionary.cs (141) : Entries[KeyFound].Add(new HashTableDictionaryItem<TKey, TValue>(key, value));
HashTableDictionary.cs (142) : NumElements++;
HashTableDictionary.cs (143) : }
HashTableDictionary.cs (145) : public void Remove(TKey key)
HashTableDictionary.cs (146) : {
HashTableDictionary.cs (147) : //TODO #6: Using FindKey, calculate where this key should be in the array of entries. Then, look for the item on the list.
HashTableDictionary.cs (148) : //          If the item is not found, do nothing
HashTableDictionary.cs (149) : //          If the item is found, remove it from the list and return
HashTableDictionary.cs (150) : int KeyFound = FindKey(key);
HashTableDictionary.cs (151) : if (Entries[KeyFound] != null)
HashTableDictionary.cs (152) : {
HashTableDictionary.cs (153) : for (int i = 0; i < Entries[KeyFound].Count(); i++)
HashTableDictionary.cs (154) : {
HashTableDictionary.cs (155) : if (Entries[KeyFound].Get(i).Key.Equals(key))
HashTableDictionary.cs (156) : {
HashTableDictionary.cs (157) : Entries[KeyFound].Remove(i);
HashTableDictionary.cs (158) : NumElements--;
HashTableDictionary.cs (159) : return;
HashTableDictionary.cs (160) : }
HashTableDictionary.cs (161) : }
HashTableDictionary.cs (162) : }
HashTableDictionary.cs (163) : }
HashTableDictionary.cs (165) : public TKey[] Keys()
HashTableDictionary.cs (166) : {
HashTableDictionary.cs (167) : //TODO #8: Return all the keys (not necessarily ordered) in an array
HashTableDictionary.cs (168) : int count = 0;
HashTableDictionary.cs (169) : TKey[] keys;
HashTableDictionary.cs (170) : if (Entries == null) { return null; }
HashTableDictionary.cs (171) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (172) : {
HashTableDictionary.cs (173) : if (Entries[i] != null)
HashTableDictionary.cs (174) : {
HashTableDictionary.cs (175) : count = count + Entries[i].Count();
HashTableDictionary.cs (176) : }
HashTableDictionary.cs (177) : }
HashTableDictionary.cs (178) : keys = new TKey[count];
HashTableDictionary.cs (179) : int num = 0;
HashTableDictionary.cs (180) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (181) : {
HashTableDictionary.cs (182) : if (Entries[i] != null)
HashTableDictionary.cs (183) : {
HashTableDictionary.cs (184) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (185) : {
HashTableDictionary.cs (186) : keys[num] = Entries[i].Get(j).Key;
HashTableDictionary.cs (187) : num++;
HashTableDictionary.cs (188) : }
HashTableDictionary.cs (189) : }
HashTableDictionary.cs (191) : }
HashTableDictionary.cs (192) : return keys;
HashTableDictionary.cs (193) : }
HashTableDictionary.cs (195) : public TValue[] Values()
HashTableDictionary.cs (196) : {
HashTableDictionary.cs (197) : //TODO #9: Return all the values (in the same order as the keys) in an array
HashTableDictionary.cs (198) : int count = 0;
HashTableDictionary.cs (199) : TValue[] values;
HashTableDictionary.cs (200) : if (Entries == null) { return null; }
HashTableDictionary.cs (201) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (202) : {
HashTableDictionary.cs (203) : if (Entries[i] != null)
HashTableDictionary.cs (204) : {
HashTableDictionary.cs (205) : count = count + Entries[i].Count();
HashTableDictionary.cs (206) : }
HashTableDictionary.cs (207) : }
HashTableDictionary.cs (208) : values = new TValue[count];
HashTableDictionary.cs (209) : int num = 0;
HashTableDictionary.cs (210) : for (int i = 0; i < Entries.Length; i++)
HashTableDictionary.cs (211) : {
HashTableDictionary.cs (212) : if (Entries[i] != null)
HashTableDictionary.cs (213) : {
HashTableDictionary.cs (214) : for (int j = 0; j < Entries[i].Count(); j++)
HashTableDictionary.cs (215) : {
HashTableDictionary.cs (216) : values[num] = Entries[i].Get(j).Value;
HashTableDictionary.cs (217) : num++;
HashTableDictionary.cs (218) : }
HashTableDictionary.cs (219) : }
HashTableDictionary.cs (221) : }
HashTableDictionary.cs (222) : return values;
HashTableDictionary.cs (223) : }
HashTableDictionary.cs (224) : }
IGenericList.cs (1) : using System;
IGenericList.cs (2) : using System.Collections;
IGenericList.cs (3) : using System.Collections.Generic;
IGenericList.cs (4) : using System.Linq;
IGenericList.cs (5) : using System.Text;
IGenericList.cs (6) : using System.Threading.Tasks;
IGenericList.cs (8) : namespace ListsStacksAndQueues
IGenericList.cs (9) : {
IGenericList.cs (10) : public interface IGenericList<T> : IEnumerable
IGenericList.cs (11) : {
IGenericList.cs (12) : int Count();
IGenericList.cs (14) : T Get(int index);
IGenericList.cs (16) : void Add(T value);
IGenericList.cs (18) : void Remove(int index);
IGenericList.cs (20) : void Clear();
IGenericList.cs (21) : }
IGenericList.cs (22) : }
UnDirectedGraph.cs (4) : using Common;
UnDirectedGraph.cs (12) : protected HashTableDictionary<TElement, Vertex<TElement, TWeight>> Vertices = new HashTableDictionary<TElement, Vertex<TElement, TWeight>>();
UnDirectedGraph.cs (19) : Vertex<TElement, TWeight>[] vertices = Vertices.Values();
UnDirectedGraph.cs (20) : for (int i = 0; i <= Vertices.Count() - 1; i++)
UnDirectedGraph.cs (21) : {
UnDirectedGraph.cs (22) : output = output + vertices[i].ToString() + "\n";
UnDirectedGraph.cs (24) : }
UnDirectedGraph.cs (34) : return Vertices.Keys(); ;
UnDirectedGraph.cs (41) : Vertices.Add(element, new Vertex<TElement, TWeight>(element));
UnDirectedGraph.cs (47) : Vertices.Get(source).AddEdge(destination, weight);
UnDirectedGraph.cs (48) : Vertices.Get(destination).AddEdge(source, weight);
UnDirectedGraph.cs (55) : return Vertices.Count();
UnDirectedGraph.cs (56) : }
UnDirectedGraph.cs (61) : int EdgeCount = 0;
UnDirectedGraph.cs (62) : Vertex<TElement, TWeight>[] vertices = Vertices.Values();
UnDirectedGraph.cs (63) : for (int i = 0; i < vertices.Length; i++)
UnDirectedGraph.cs (64) : {
UnDirectedGraph.cs (65) : EdgeCount += vertices[i].EdgeCount();
UnDirectedGraph.cs (66) : }
UnDirectedGraph.cs (67) : return EdgeCount/2;
UnDirectedGraph.cs (73) : Vertex<TElement, TWeight> VSource = Vertices.Get(source);
UnDirectedGraph.cs (74) : Vertex<TElement, TWeight> VDestination = Vertices.Get(destination);
UnDirectedGraph.cs (76) : if (VSource != null && VDestination != null)
UnDirectedGraph.cs (77) : {
UnDirectedGraph.cs (78) : return VSource.GetEdgeWeight(VDestination.Element);
UnDirectedGraph.cs (79) : }
UnDirectedGraph.cs (86) : Vertices.Get(source).Edges.Remove(destination);
UnDirectedGraph.cs (92) : Vertex<TElement, TWeight> actual = Vertices.Get(element);
UnDirectedGraph.cs (93) : TElement[] tabla = actual.ConnectedElements();
UnDirectedGraph.cs (94) : for(int i = 0; i < tabla.Length; i++)
UnDirectedGraph.cs (95) : {
UnDirectedGraph.cs (96) : Vertices.Get(element).RemoveEdge(tabla[i]);
UnDirectedGraph.cs (97) : Vertices.Get(tabla[i]).RemoveEdge(element);
UnDirectedGraph.cs (98) : }
UnDirectedGraph.cs (99) : Vertices.Remove(element);
UnDirectedGraph.cs (106) : return Vertices.Get(element);
Vertex.cs (8) : public HashTableDictionary<TElement, TWeight> Edges = new HashTableDictionary<TElement, TWeight>();
Vertex.cs (20) : TElement[] elementos = Edges.Keys();
Vertex.cs (21) : TElement[] tabla = new TElement[elementos.Length];
Vertex.cs (23) : for (int i = 0; i < tabla.Length;i++)
Vertex.cs (24) : {
Vertex.cs (25) : tabla[i] = elementos[i];
Vertex.cs (26) : }
Vertex.cs (27) : return tabla;
Vertex.cs (34) : Edges.Add(targetElement, weight);
Vertex.cs (41) : return Edges.Count();
Vertex.cs (48) : Edges.Remove(targetElement);
Vertex.cs (54) : TElement[] elements = Edges.Keys();
Vertex.cs (55) : TWeight[] weights = Edges.Values();
Vertex.cs (56) : for(int i=0; i < elements.Length; i++)
Vertex.cs (58) : if (elements[i].Equals(targetElement))
Vertex.cs (75) : string output = "";
Vertex.cs (76) : TElement[] elements = Edges.Keys();
Vertex.cs (77) : TWeight[] pesos = Edges.Values();
Vertex.cs (79) : for(int i=0; i < elements.Length; i++)
Vertex.cs (81) : output = output + Element + "->" + pesos[i] + "->" + elements[i] + "\n";
