BinaryTree.cs (83) : if (start > end)
BinaryTree.cs (84) : {
BinaryTree.cs (86) : }
BinaryTree.cs (87) : int center = (start + end) / 2;
BinaryTree.cs (88) : BinaryTreeNode<TKey, TValue> newNode = new BinaryTreeNode<TKey, TValue>(keys[center], values[center]);
BinaryTree.cs (89) : newNode.LeftChild = AddBalanced(keys, values, start, center - 1);
BinaryTree.cs (90) : newNode.RightChild = AddBalanced(keys, values, center + 1, end);
BinaryTree.cs (91) : return newNode;
BinaryTreeNode.cs (15) : Key = key;
BinaryTreeNode.cs (16) : Value = value;
BinaryTreeNode.cs (17) : LeftChild = null;
BinaryTreeNode.cs (18) : RightChild = null;
BinaryTreeNode.cs (51) : int comparar = this.Key.CompareTo(node.Key);
BinaryTreeNode.cs (52) : if (comparar > 0)
BinaryTreeNode.cs (53) : {
BinaryTreeNode.cs (54) : //el nuevo nodo debe ir a la izquierda
BinaryTreeNode.cs (55) : if (this.LeftChild == null)
BinaryTreeNode.cs (56) : {
BinaryTreeNode.cs (57) : this.LeftChild = node;
BinaryTreeNode.cs (58) : }
BinaryTreeNode.cs (59) : else
BinaryTreeNode.cs (60) : {
BinaryTreeNode.cs (61) : this.LeftChild.Add(node);
BinaryTreeNode.cs (62) : }
BinaryTreeNode.cs (63) : }
BinaryTreeNode.cs (64) : if (comparar < 0)
BinaryTreeNode.cs (65) : {
BinaryTreeNode.cs (66) : //el nuevo nodo debe ir a la derecha
BinaryTreeNode.cs (67) : if (this.RightChild == null)
BinaryTreeNode.cs (68) : {
BinaryTreeNode.cs (69) : this.RightChild = node;
BinaryTreeNode.cs (70) : }
BinaryTreeNode.cs (71) : else
BinaryTreeNode.cs (72) : {
BinaryTreeNode.cs (73) : this.RightChild.Add(node);
BinaryTreeNode.cs (74) : }
BinaryTreeNode.cs (75) : }
BinaryTreeNode.cs (76) : else
BinaryTreeNode.cs (77) : {
BinaryTreeNode.cs (78) : //las claves son iguales, actualizamos el valor
BinaryTreeNode.cs (79) : this.Value = node.Value;
BinaryTreeNode.cs (80) : }
BinaryTreeNode.cs (88) : int numElements = 1; // empieza en 1 porque un árbol ya contiene al menos un nodo
BinaryTreeNode.cs (89) : if (LeftChild != null)
BinaryTreeNode.cs (90) : {
BinaryTreeNode.cs (91) : numElements += LeftChild.Count();
BinaryTreeNode.cs (92) : }
BinaryTreeNode.cs (93) : if (RightChild != null)
BinaryTreeNode.cs (94) : {
BinaryTreeNode.cs (95) : numElements += RightChild.Count();
BinaryTreeNode.cs (96) : }
BinaryTreeNode.cs (97) : return numElements;
BinaryTreeNode.cs (105) : int alturaIzquierda = 0;
BinaryTreeNode.cs (106) : int alturaDerecha = 0;
BinaryTreeNode.cs (107) : //si no hay un nodo, la altura es -1
BinaryTreeNode.cs (108) : if (this == null)
BinaryTreeNode.cs (109) : {
BinaryTreeNode.cs (110) : return -1;
BinaryTreeNode.cs (111) : }
BinaryTreeNode.cs (112) : //si no tiene hijos, la altura es 0
BinaryTreeNode.cs (113) : if (LeftChild == null && RightChild == null)
BinaryTreeNode.cs (114) : {
BinaryTreeNode.cs (116) : }
BinaryTreeNode.cs (117) : //Si tiene hijos, calculamos la altura de cada uno y devolvemos la mayor + 1
BinaryTreeNode.cs (118) : if (LeftChild != null)
BinaryTreeNode.cs (119) : {
BinaryTreeNode.cs (120) : alturaIzquierda = LeftChild.Height();
BinaryTreeNode.cs (121) : }
BinaryTreeNode.cs (122) : if (RightChild != null)
BinaryTreeNode.cs (123) : {
BinaryTreeNode.cs (124) : alturaDerecha = RightChild.Height();
BinaryTreeNode.cs (125) : }
BinaryTreeNode.cs (126) : return 1 + Math.Max(alturaIzquierda, alturaDerecha);
BinaryTreeNode.cs (139) : int comparar = this.Key.CompareTo(key);
BinaryTreeNode.cs (140) : if (comparar > 0)
BinaryTreeNode.cs (141) : {
BinaryTreeNode.cs (142) : //la clave que buscamos está a la izquierda
BinaryTreeNode.cs (143) : if (this.LeftChild == null)
BinaryTreeNode.cs (144) : {
BinaryTreeNode.cs (145) : return default(TValue);
BinaryTreeNode.cs (146) : }
BinaryTreeNode.cs (147) : else
BinaryTreeNode.cs (148) : {
BinaryTreeNode.cs (149) : return this.LeftChild.Get(key);
BinaryTreeNode.cs (150) : }
BinaryTreeNode.cs (151) : }
BinaryTreeNode.cs (152) : if (comparar < 0)
BinaryTreeNode.cs (153) : {
BinaryTreeNode.cs (154) : //la clave que buscamos está a la derecha
BinaryTreeNode.cs (155) : if (this.RightChild == null)
BinaryTreeNode.cs (156) : {
BinaryTreeNode.cs (157) : return default(TValue);
BinaryTreeNode.cs (158) : }
BinaryTreeNode.cs (159) : else
BinaryTreeNode.cs (160) : {
BinaryTreeNode.cs (161) : return this.RightChild.Get(key);
BinaryTreeNode.cs (162) : }
BinaryTreeNode.cs (163) : }
BinaryTreeNode.cs (164) : else
BinaryTreeNode.cs (165) : {
BinaryTreeNode.cs (166) : //las claves son iguales, devolvemos el valor
BinaryTreeNode.cs (167) : return this.Value;
BinaryTreeNode.cs (168) : }
BinaryTreeNode.cs (181) : //si la clave que queremos eliminar es menos que mi clave
BinaryTreeNode.cs (182) : if (this.Key.CompareTo(key) > 0)
BinaryTreeNode.cs (183) : {
BinaryTreeNode.cs (184) : //la clave que buscamos está a la izquierda
BinaryTreeNode.cs (185) : if (this.LeftChild != null)
BinaryTreeNode.cs (186) : {
BinaryTreeNode.cs (187) : //lo que devuelva el hijo pasa a ser mi hijo izquierdo
BinaryTreeNode.cs (188) : this.LeftChild = this.LeftChild.Remove(key);
BinaryTreeNode.cs (189) : }
BinaryTreeNode.cs (190) : return this;
BinaryTreeNode.cs (191) : }
BinaryTreeNode.cs (192) : //si la clave que queremos eliminar es mayor que mi clave
BinaryTreeNode.cs (193) : if (this.Key.CompareTo(key) < 0)
BinaryTreeNode.cs (194) : {
BinaryTreeNode.cs (195) : //la clave que buscamos está a la derecha
BinaryTreeNode.cs (196) : if (this.RightChild != null)
BinaryTreeNode.cs (197) : {
BinaryTreeNode.cs (198) : //lo que devuelva el hijo pasa a ser mi hijo derecho
BinaryTreeNode.cs (199) : this.RightChild = this.RightChild.Remove(key);
BinaryTreeNode.cs (200) : }
BinaryTreeNode.cs (201) : return this;
BinaryTreeNode.cs (202) : }
BinaryTreeNode.cs (203) : else
BinaryTreeNode.cs (204) : {
BinaryTreeNode.cs (205) : //las claves son iguales, este es el nodo a eliminar
BinaryTreeNode.cs (206) : //caso 1: nodo sin hijos
BinaryTreeNode.cs (207) : if (this.LeftChild == null && this.RightChild == null)
BinaryTreeNode.cs (208) : {
BinaryTreeNode.cs (210) : }
BinaryTreeNode.cs (211) : //caso 2: nodo con un hijo
BinaryTreeNode.cs (212) : //si no tiene hijo izquierdo
BinaryTreeNode.cs (213) : if (this.LeftChild == null)
BinaryTreeNode.cs (214) : {
BinaryTreeNode.cs (215) : return this.RightChild;
BinaryTreeNode.cs (216) : }
BinaryTreeNode.cs (217) : //si no tiene hijo derecho
BinaryTreeNode.cs (218) : if (this.RightChild == null)
BinaryTreeNode.cs (219) : {
BinaryTreeNode.cs (220) : return this.LeftChild;
BinaryTreeNode.cs (221) : }
BinaryTreeNode.cs (222) : //caso 3: nodo con dos hijos
BinaryTreeNode.cs (223) : //guardamos subarboles
BinaryTreeNode.cs (224) : BinaryTreeNode<TKey, TValue> subarbolIzquierdo = this.LeftChild;
BinaryTreeNode.cs (225) : BinaryTreeNode<TKey, TValue> subarbolDerecho = this.RightChild;
BinaryTreeNode.cs (226) : //le asignamos al subarbol izquierdo el subarbol derecho como hijo derecho
BinaryTreeNode.cs (227) : subarbolIzquierdo.Add(subarbolDerecho);
BinaryTreeNode.cs (228) : return subarbolIzquierdo;
BinaryTreeNode.cs (229) : }
TreeNode.cs (70) : return 0;
TreeNode.cs (83) : //Se le suma 1 a la altura del hijo mas alto para contar el nodo actual
TreeNode.cs (118) : //primero comprobamos si el valor del nodo actual coincide con el valor buscado
TreeNode.cs (119) : if (this.Value.Equals(value))
TreeNode.cs (120) : {
TreeNode.cs (121) : return this;
TreeNode.cs (122) : }
TreeNode.cs (123) : else
TreeNode.cs (124) : {
TreeNode.cs (125) : //si no coincide busscamos en los hijos con un for
TreeNode.cs (126) : for (int i = 0; i < Children.Count(); i++)
TreeNode.cs (127) : {
TreeNode.cs (128) : TreeNode<T> child = Children.Get(i);
TreeNode.cs (129) : TreeNode<T> hijoEncontrado = child.Find(value);
TreeNode.cs (131) : if (hijoEncontrado != null)
TreeNode.cs (132) : {
TreeNode.cs (133) : return hijoEncontrado;
TreeNode.cs (134) : }
TreeNode.cs (135) : }
TreeNode.cs (138) : }
TreeNode.cs (145) : for (int i = 0; i < Children.Count(); i++)
TreeNode.cs (146) : {
TreeNode.cs (147) : TreeNode<T> child = Children.Get(i);
TreeNode.cs (148) : //Si el hijo actual es el nodo que queremos eliminar
TreeNode.cs (149) : if (child == node)
TreeNode.cs (150) : {
TreeNode.cs (151) : //lo removemos de la lista de hijos
TreeNode.cs (152) : Children.Remove(i);
TreeNode.cs (153) : return;
TreeNode.cs (154) : }
TreeNode.cs (155) : else
TreeNode.cs (156) : {
TreeNode.cs (157) : // Si no coincide, buscamos recursivamente dentro de ese hijo, para quitar todos los hijos de ese hijo
TreeNode.cs (158) : child.Remove(node);
TreeNode.cs (159) : }
TreeNode.cs (160) : }
