BinaryTree.cs (83) : if (start > end)
BinaryTree.cs (84) : {
BinaryTree.cs (86) : }
BinaryTree.cs (87) : int center = (start + end) / 2;
BinaryTree.cs (88) : BinaryTreeNode<TKey, TValue> newNode = new BinaryTreeNode<TKey, TValue>(keys[center], values[center]);
BinaryTree.cs (89) : newNode.LeftChild = AddBalanced(keys, values, start, center - 1);
BinaryTree.cs (90) : newNode.RightChild = AddBalanced(keys, values, center + 1, end);
BinaryTree.cs (91) : return newNode;
BinaryTreeNode.cs (15) : Key = key;
BinaryTreeNode.cs (16) : Value = value;
BinaryTreeNode.cs (49) : int comparar = this.Key.CompareTo(node.Key);
BinaryTreeNode.cs (50) : if (comparar > 0)
BinaryTreeNode.cs (51) : {
BinaryTreeNode.cs (52) : //el nuevo nodo debe ir a la izquierda
BinaryTreeNode.cs (53) : if (LeftChild == null)
BinaryTreeNode.cs (54) : {
BinaryTreeNode.cs (55) : LeftChild = node;
BinaryTreeNode.cs (56) : }
BinaryTreeNode.cs (57) : else
BinaryTreeNode.cs (58) : {
BinaryTreeNode.cs (59) : this.LeftChild.Add(node);
BinaryTreeNode.cs (60) : }
BinaryTreeNode.cs (61) : }
BinaryTreeNode.cs (62) : if (comparar < 0)
BinaryTreeNode.cs (63) : {
BinaryTreeNode.cs (64) : //el nuevo nodo debe ir a la derecha
BinaryTreeNode.cs (65) : if (RightChild == null)
BinaryTreeNode.cs (66) : {
BinaryTreeNode.cs (67) : RightChild = node;
BinaryTreeNode.cs (68) : }
BinaryTreeNode.cs (69) : else
BinaryTreeNode.cs (70) : {
BinaryTreeNode.cs (71) : RightChild.Add(node);
BinaryTreeNode.cs (72) : }
BinaryTreeNode.cs (73) : }
BinaryTreeNode.cs (74) : else
BinaryTreeNode.cs (75) : {
BinaryTreeNode.cs (76) : //las claves son iguales, actualizamos el valor
BinaryTreeNode.cs (77) : Value = node.Value;
BinaryTreeNode.cs (78) : }
BinaryTreeNode.cs (86) : int numElements = 1; // empieza en 1 porque un árbol ya contiene al menos un nodo
BinaryTreeNode.cs (87) : if (LeftChild != null)
BinaryTreeNode.cs (88) : {
BinaryTreeNode.cs (89) : numElements += LeftChild.Count();
BinaryTreeNode.cs (90) : }
BinaryTreeNode.cs (91) : if (RightChild != null)
BinaryTreeNode.cs (92) : {
BinaryTreeNode.cs (93) : numElements += RightChild.Count();
BinaryTreeNode.cs (94) : }
BinaryTreeNode.cs (95) : return numElements;
BinaryTreeNode.cs (103) : int alturaIzquierda = 0;
BinaryTreeNode.cs (104) : int alturaDerecha = 0;
BinaryTreeNode.cs (105) : //si no hay un nodo, la altura es -1
BinaryTreeNode.cs (106) : if (this == null)
BinaryTreeNode.cs (107) : {
BinaryTreeNode.cs (108) : return -1;
BinaryTreeNode.cs (109) : }
BinaryTreeNode.cs (110) : //si no tiene hijos, la altura es 0
BinaryTreeNode.cs (111) : if (LeftChild == null && RightChild == null)
BinaryTreeNode.cs (112) : {
BinaryTreeNode.cs (114) : }
BinaryTreeNode.cs (115) : //Si tiene hijos, calculamos la altura de cada uno y devolvemos la mayor + 1
BinaryTreeNode.cs (116) : if (LeftChild != null)
BinaryTreeNode.cs (117) : {
BinaryTreeNode.cs (118) : alturaIzquierda = LeftChild.Height();
BinaryTreeNode.cs (119) : }
BinaryTreeNode.cs (120) : if (RightChild != null)
BinaryTreeNode.cs (121) : {
BinaryTreeNode.cs (122) : alturaDerecha = RightChild.Height();
BinaryTreeNode.cs (123) : }
BinaryTreeNode.cs (124) : return 1 + Math.Max(alturaIzquierda, alturaDerecha);
BinaryTreeNode.cs (137) : int comparar = this.Key.CompareTo(key);
BinaryTreeNode.cs (138) : if (comparar > 0)
BinaryTreeNode.cs (139) : {
BinaryTreeNode.cs (140) : //la clave que buscamos está a la izquierda
BinaryTreeNode.cs (141) : if (LeftChild == null)
BinaryTreeNode.cs (142) : {
BinaryTreeNode.cs (143) : return default(TValue);
BinaryTreeNode.cs (144) : }
BinaryTreeNode.cs (145) : else
BinaryTreeNode.cs (146) : {
BinaryTreeNode.cs (147) : return LeftChild.Get(key);
BinaryTreeNode.cs (148) : }
BinaryTreeNode.cs (149) : }
BinaryTreeNode.cs (150) : if (comparar < 0)
BinaryTreeNode.cs (151) : {
BinaryTreeNode.cs (152) : //la clave que buscamos está a la derecha
BinaryTreeNode.cs (153) : if (RightChild == null)
BinaryTreeNode.cs (154) : {
BinaryTreeNode.cs (155) : return default(TValue);
BinaryTreeNode.cs (156) : }
BinaryTreeNode.cs (157) : else
BinaryTreeNode.cs (158) : {
BinaryTreeNode.cs (159) : return RightChild.Get(key);
BinaryTreeNode.cs (160) : }
BinaryTreeNode.cs (161) : }
BinaryTreeNode.cs (162) : else
BinaryTreeNode.cs (163) : {
BinaryTreeNode.cs (164) : //las claves son iguales, devolvemos el valor
BinaryTreeNode.cs (165) : return Value;
BinaryTreeNode.cs (166) : }
BinaryTreeNode.cs (179) : //si la clave que queremos eliminar es menos que mi clave
BinaryTreeNode.cs (180) : if (this.Key.CompareTo(key) > 0)
BinaryTreeNode.cs (181) : {
BinaryTreeNode.cs (182) : //la clave que buscamos está a la izquierda
BinaryTreeNode.cs (183) : if (this.LeftChild != null)
BinaryTreeNode.cs (184) : {
BinaryTreeNode.cs (185) : //lo que devuelva el hijo pasa a ser mi hijo izquierdo
BinaryTreeNode.cs (186) : this.LeftChild = this.LeftChild.Remove(key);
BinaryTreeNode.cs (187) : }
BinaryTreeNode.cs (188) : return this;
BinaryTreeNode.cs (189) : }
BinaryTreeNode.cs (190) : //si la clave que queremos eliminar es mayor que mi clave
BinaryTreeNode.cs (191) : if (this.Key.CompareTo(key) < 0)
BinaryTreeNode.cs (192) : {
BinaryTreeNode.cs (193) : //la clave que buscamos está a la derecha
BinaryTreeNode.cs (194) : if (this.RightChild != null)
BinaryTreeNode.cs (195) : {
BinaryTreeNode.cs (196) : //lo que devuelva el hijo pasa a ser mi hijo derecho
BinaryTreeNode.cs (197) : this.RightChild = this.RightChild.Remove(key);
BinaryTreeNode.cs (198) : }
BinaryTreeNode.cs (199) : return this;
BinaryTreeNode.cs (200) : }
BinaryTreeNode.cs (201) : //else
BinaryTreeNode.cs (203) : //las claves son iguales, este es el nodo a eliminar
BinaryTreeNode.cs (204) : //caso 1: nodo sin hijos
BinaryTreeNode.cs (205) : if (this.LeftChild == null && this.RightChild == null)
BinaryTreeNode.cs (206) : {
BinaryTreeNode.cs (208) : }
BinaryTreeNode.cs (209) : //caso 2: nodo con un hijo
BinaryTreeNode.cs (210) : //si no tiene hijo izquierdo
BinaryTreeNode.cs (211) : if (this.LeftChild == null)
BinaryTreeNode.cs (212) : {
BinaryTreeNode.cs (213) : return this.RightChild;
BinaryTreeNode.cs (214) : }
BinaryTreeNode.cs (215) : //si no tiene hijo derecho
BinaryTreeNode.cs (216) : if (this.RightChild == null)
BinaryTreeNode.cs (217) : {
BinaryTreeNode.cs (218) : return this.LeftChild;
BinaryTreeNode.cs (219) : }
BinaryTreeNode.cs (220) : //caso 3: nodo con dos hijos
BinaryTreeNode.cs (221) : //guardamos subarboles
BinaryTreeNode.cs (222) : BinaryTreeNode<TKey, TValue> subarbolIzquierdo = this.LeftChild;
BinaryTreeNode.cs (223) : BinaryTreeNode<TKey, TValue> subarbolDerecho = this.RightChild;
BinaryTreeNode.cs (224) : //le asignamos al subarbol izquierdo el subarbol derecho como hijo derecho
BinaryTreeNode.cs (225) : subarbolIzquierdo.Add(subarbolDerecho);
BinaryTreeNode.cs (226) : return subarbolIzquierdo;
TreeNode.cs (70) : return 0;
TreeNode.cs (83) : //Se le suma 1 a la altura del hijo mas alto para contar el nodo actual
TreeNode.cs (118) : //primero comprobamos si el valor del nodo actual coincide con el valor buscado
TreeNode.cs (119) : if (this.Value.Equals(value))
TreeNode.cs (120) : {
TreeNode.cs (121) : return this;
TreeNode.cs (122) : }
TreeNode.cs (123) : else
TreeNode.cs (124) : {
TreeNode.cs (125) : //si no coincide busscamos en los hijos con un for
TreeNode.cs (126) : for (int i = 0; i < Children.Count(); i++)
TreeNode.cs (127) : {
TreeNode.cs (128) : TreeNode<T> child = Children.Get(i);
TreeNode.cs (129) : TreeNode<T> hijoEncontrado = child.Find(value);
TreeNode.cs (131) : if (hijoEncontrado != null)
TreeNode.cs (132) : {
TreeNode.cs (133) : return hijoEncontrado;
TreeNode.cs (134) : }
TreeNode.cs (135) : }
TreeNode.cs (138) : }
TreeNode.cs (145) : for (int i = 0; i < Children.Count(); i++)
TreeNode.cs (146) : {
TreeNode.cs (147) : TreeNode<T> child = Children.Get(i);
TreeNode.cs (148) : //Si el hijo actual es el nodo que queremos eliminar
TreeNode.cs (149) : if (child == node)
TreeNode.cs (150) : {
TreeNode.cs (151) : //lo removemos de la lista de hijos
TreeNode.cs (152) : Children.Remove(i);
TreeNode.cs (153) : return;
TreeNode.cs (154) : }
TreeNode.cs (155) : else
TreeNode.cs (156) : {
TreeNode.cs (157) : // Si no coincide, buscamos recursivamente dentro de ese hijo, para quitar todos los hijos de ese hijo
TreeNode.cs (158) : child.Remove(node);
TreeNode.cs (159) : }
TreeNode.cs (160) : }
